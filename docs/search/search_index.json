{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"architecture/","text":"Overview The system is structured as a client-server architecture. Clients communicate with the server using a server API and websocket connections. The server makes use of a database to store information about the users and the matches. Diagram The following diagram provides an abstract overall outline of the entities in the system and the relationship between them. Database The system's server makes use of a database in order to keep track of the information required for the correct functioning of the platform. The different kind of information are stored in separate SQL tables, which are: rest_api_user - Stores different information about the users. rest_api_ongoingmatch - Stores information about ongoing matches. rest_api_completedmatch - Stores information about completed matches. authtoken_token - Stores tokens and relative users. Users The system stores the following login information in order to let them register to the platform and keep track of their progress. username - Unique username associated to the player required to log in. password - Password established at registration time, required to log in. Passwords are hashed using PBKDF2 as to preserve the privacy of the users. email - E-mail address associated to the account. Other information concerning the gaming state of the user is stored, such as: ongoing_match_id - Containing the unique identifier of the match in which the user is participating, if playing, otherwise <null> . role - Containing information about the role of the player, if associated to an ongoing match. The different possible roles are: host , challenger , spectator . Fields carrying other generic information about the user are: elo - Rating score indicating the skill level of the player. date_joined - Date and time of the registration of the user. last_login - Date and time of the last log in of the user. Here follows an example of the rest_api_user dataset table. id password last_login username email date_joined role ongoing_match_id elo 1 pbkdf2_sha256$... 2021-01-18 18:00:00 davide d.cafaro4@studenti.unisa.it 2021-01-18 H 3 1000 2 pbkdf2_sha256$... 2021-01-18 18:00:00 emanuele e.darminio4@studenti.unisa.it 2021-01-18 C 3 1000 3 pbkdf2_sha256$... 2021-01-18 18:00:00 marta m.silla@studenti.unisa.it 2021-01-18 S 3 1000 Ongoing matches To correctly link players and spectators to the same match and synchronize their gaming status, each user keeps a reference to the relative ongoing match. The list of ongoing matches is stored in the dataset. Each entry contains the following fields: id - Unique identifier of the match. creation_timestamp - Date and time of the creation of the match by the host. start_timestamp - Date and time of the start of the match. is_started - Boolean value used to know whether the game has started. is_challenger_ready - Boolean value used to alert the host that the challenger is ready. Here follows an example of the rest_api_ongoing_matches dataset table. id creation_timestamp start_timestamp is_started is_challenger_ready 3 2021-01-18 18:48:00 2021-01-18 18:50:00 1 1 Completed matches When a match is completed the system stores its relative information, along with the players scores and elos, in order to keep track of their progress. id start_timestamp completion_timestamp loser_id winner_id loser_elo_after_match loser_elo_before_match loser_score winner_elo_after_match winner_elo_before_match winner_score 1 2021-01-18 18:18:00 2021-01-18 18:30:00 1 2 950 1000 4 1050 1000 5 2 2021-01-18 18:28:00 2021-01-18 18:40:00 2 1 1000 1050 4 950 1000 5 Contraints To preserve the accuracy and the reliability of the data in the database, additional constraints are specified for SQL tables containing information about matches. Loser ID and winner ID must be different, the score of the winner must be higher than the score of the loser and the elo of the player must be coherently increase in case of victory and decrease in case of defeat. Also completion time must be subsequent to start time. Tokens The token based authentication provided by the Django REST framework is used to allow users to verify their identity After the registration of a new user, the login function returns the token associated with the user. This token is then used to access the authenticated API. In order to verify the identity of the user, tokens are stored in a SQL table and associated with the corresponding user ID as follows: key created user_id fd726egydgnf75g... 2021-01-18 18:00:00 1 9h87ydb8ag8hjg6... 2021-01-18 18:00:00 2 uhdsa8dadh1hgf5... 2021-01-18 18:00:00 3 Server API Users can register to the platform through the server API. (con la post) After signing up each user is associated to a token used to authenticate themself when logging in. Once authenticated, users can access the list of registered users, ongoing matches and completed matches. (e vedere le info filtrate) Through a POST operation on the server API, users can create a new ongoing match, for which they'll assume the role of host. The server returns the ID of the match. WebSockets Potential challengers and spectators can access the list of ongoing matches through the API server and establish a websocket connection with the server. Server handles websocket protocol requests during the game and updates the clients about the state of the match. Client After the connection is established and both players are ready, the clients can start a session and begin exchanging information with the server through the socket. In particular, the players can use the socket to send commands to the server so it can update the state of the game. The commands can be: up , down , fast up , fast down .","title":"Overview"},{"location":"architecture/#overview","text":"The system is structured as a client-server architecture. Clients communicate with the server using a server API and websocket connections. The server makes use of a database to store information about the users and the matches.","title":"Overview"},{"location":"architecture/#diagram","text":"The following diagram provides an abstract overall outline of the entities in the system and the relationship between them.","title":"Diagram"},{"location":"architecture/#database","text":"The system's server makes use of a database in order to keep track of the information required for the correct functioning of the platform. The different kind of information are stored in separate SQL tables, which are: rest_api_user - Stores different information about the users. rest_api_ongoingmatch - Stores information about ongoing matches. rest_api_completedmatch - Stores information about completed matches. authtoken_token - Stores tokens and relative users.","title":"Database"},{"location":"architecture/#users","text":"The system stores the following login information in order to let them register to the platform and keep track of their progress. username - Unique username associated to the player required to log in. password - Password established at registration time, required to log in. Passwords are hashed using PBKDF2 as to preserve the privacy of the users. email - E-mail address associated to the account. Other information concerning the gaming state of the user is stored, such as: ongoing_match_id - Containing the unique identifier of the match in which the user is participating, if playing, otherwise <null> . role - Containing information about the role of the player, if associated to an ongoing match. The different possible roles are: host , challenger , spectator . Fields carrying other generic information about the user are: elo - Rating score indicating the skill level of the player. date_joined - Date and time of the registration of the user. last_login - Date and time of the last log in of the user. Here follows an example of the rest_api_user dataset table. id password last_login username email date_joined role ongoing_match_id elo 1 pbkdf2_sha256$... 2021-01-18 18:00:00 davide d.cafaro4@studenti.unisa.it 2021-01-18 H 3 1000 2 pbkdf2_sha256$... 2021-01-18 18:00:00 emanuele e.darminio4@studenti.unisa.it 2021-01-18 C 3 1000 3 pbkdf2_sha256$... 2021-01-18 18:00:00 marta m.silla@studenti.unisa.it 2021-01-18 S 3 1000","title":"Users"},{"location":"architecture/#ongoing-matches","text":"To correctly link players and spectators to the same match and synchronize their gaming status, each user keeps a reference to the relative ongoing match. The list of ongoing matches is stored in the dataset. Each entry contains the following fields: id - Unique identifier of the match. creation_timestamp - Date and time of the creation of the match by the host. start_timestamp - Date and time of the start of the match. is_started - Boolean value used to know whether the game has started. is_challenger_ready - Boolean value used to alert the host that the challenger is ready. Here follows an example of the rest_api_ongoing_matches dataset table. id creation_timestamp start_timestamp is_started is_challenger_ready 3 2021-01-18 18:48:00 2021-01-18 18:50:00 1 1","title":"Ongoing matches"},{"location":"architecture/#completed-matches","text":"When a match is completed the system stores its relative information, along with the players scores and elos, in order to keep track of their progress. id start_timestamp completion_timestamp loser_id winner_id loser_elo_after_match loser_elo_before_match loser_score winner_elo_after_match winner_elo_before_match winner_score 1 2021-01-18 18:18:00 2021-01-18 18:30:00 1 2 950 1000 4 1050 1000 5 2 2021-01-18 18:28:00 2021-01-18 18:40:00 2 1 1000 1050 4 950 1000 5","title":"Completed matches"},{"location":"architecture/#tokens","text":"The token based authentication provided by the Django REST framework is used to allow users to verify their identity After the registration of a new user, the login function returns the token associated with the user. This token is then used to access the authenticated API. In order to verify the identity of the user, tokens are stored in a SQL table and associated with the corresponding user ID as follows: key created user_id fd726egydgnf75g... 2021-01-18 18:00:00 1 9h87ydb8ag8hjg6... 2021-01-18 18:00:00 2 uhdsa8dadh1hgf5... 2021-01-18 18:00:00 3","title":"Tokens"},{"location":"architecture/#server","text":"","title":"Server"},{"location":"architecture/#api","text":"Users can register to the platform through the server API. (con la post) After signing up each user is associated to a token used to authenticate themself when logging in. Once authenticated, users can access the list of registered users, ongoing matches and completed matches. (e vedere le info filtrate) Through a POST operation on the server API, users can create a new ongoing match, for which they'll assume the role of host. The server returns the ID of the match.","title":"API"},{"location":"architecture/#websockets","text":"Potential challengers and spectators can access the list of ongoing matches through the API server and establish a websocket connection with the server. Server handles websocket protocol requests during the game and updates the clients about the state of the match.","title":"WebSockets"},{"location":"architecture/#client","text":"After the connection is established and both players are ready, the clients can start a session and begin exchanging information with the server through the socket. In particular, the players can use the socket to send commands to the server so it can update the state of the game. The commands can be: up , down , fast up , fast down .","title":"Client"},{"location":"code-description-and-examples/","text":"The code is organized in Python packages as below. The highlighted packages are the most interesting packages - that is, containing most of the logic of the project. Directory tree \u251c\u2500\u2500 DistributedProgrammingLHobby \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 asgi.py \u2502 \u251c\u2500\u2500 settings.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 wsgi.py \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 markdown \u2502 \u2502 \u251c\u2500\u2500 ... (this documentation files) \u251c\u2500\u2500 game \u2502 \u251c\u2500\u2500 authentication \u2502 \u2502 \u2514\u2500\u2500 token.py \u2502 \u251c\u2500\u2500 pong \u2502 \u2502 \u251c\u2500\u2500 queue \u2502 \u2502 \u2502 \u251c\u2500\u2500 circular_queue.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 input.py \u2502 \u2502 \u2502 \u2514\u2500\u2500 output.py \u2502 \u2502 \u251c\u2500\u2500 test \u2502 \u2502 \u2502 \u251c\u2500\u2500 input.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 output.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u2502 \u2502 \u2514\u2500\u2500 testing.py \u2502 \u2502 \u251c\u2500\u2500 ball.py \u2502 \u2502 \u251c\u2500\u2500 controller.py \u2502 \u2502 \u251c\u2500\u2500 game_rules.py \u2502 \u2502 \u2514\u2500\u2500 paddle.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 apps.py \u2502 \u251c\u2500\u2500 consumers.py \u2502 \u251c\u2500\u2500 pong_output_consumer.py \u2502 \u2514\u2500\u2500 routing.py \u251c\u2500\u2500 rest_api \u2502 \u251c\u2500\u2500 migrations \u2502 \u2502 \u251c\u2500\u2500 ... (database migration files) \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 apps.py \u2502 \u251c\u2500\u2500 filters.py \u2502 \u251c\u2500\u2500 models.py \u2502 \u251c\u2500\u2500 serializers.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 views.py \u251c\u2500\u2500 client \u2502 \u251c\u2500\u2500 pygame_client.py \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u2514\u2500\u2500 retro.ttf \u251c\u2500\u2500 db.sqlite3 \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 requirements.txt Packages description DistributedProgrammingLHobby is the Django site directory, containing global settings for the whole server application. In particular, here it is defined: the HTTP handler (the rest_api package), the Websockets handler (the game package), the DBMS (SQLite3), the Django Channels channel_layer (a local Redis instance \u2014 a powerful engine was required for the game to be correctly handled in real-time with multiple connected users), supported authentication methods (token-auth aimed at stand-alone clients and cookie-based aimed at browser clients). docs is the package containing the Markdown files and the custom styles of this documentation, built with the Mkdocs static-site engine. game is responsible for handling the Websocket protocol requests, running the actual games using the code in the pong module, updating clients on the state of the game, and changing the database according to the match results. rest_api implements the API of the server from the ground up: it defines the SQL tables as a series of Django models and exposes them RESTfully. client is a simple implementation of a client which interacts with both the API and the Websocket server to demonstrate a typical user session on the LHobby platform. Info The provided program is a command-line client which does not implement all the possible actions a user may actually take using the server directly with a REST client. It is therefore only intended to show the core functionality of the project, while much more could be achieved with a more complex client. In the next sections, interesting project parts will be explored more deeply.","title":"Project structure"},{"location":"code-description-and-examples/#packages-description","text":"DistributedProgrammingLHobby is the Django site directory, containing global settings for the whole server application. In particular, here it is defined: the HTTP handler (the rest_api package), the Websockets handler (the game package), the DBMS (SQLite3), the Django Channels channel_layer (a local Redis instance \u2014 a powerful engine was required for the game to be correctly handled in real-time with multiple connected users), supported authentication methods (token-auth aimed at stand-alone clients and cookie-based aimed at browser clients). docs is the package containing the Markdown files and the custom styles of this documentation, built with the Mkdocs static-site engine. game is responsible for handling the Websocket protocol requests, running the actual games using the code in the pong module, updating clients on the state of the game, and changing the database according to the match results. rest_api implements the API of the server from the ground up: it defines the SQL tables as a series of Django models and exposes them RESTfully. client is a simple implementation of a client which interacts with both the API and the Websocket server to demonstrate a typical user session on the LHobby platform. Info The provided program is a command-line client which does not implement all the possible actions a user may actually take using the server directly with a REST client. It is therefore only intended to show the core functionality of the project, while much more could be achieved with a more complex client. In the next sections, interesting project parts will be explored more deeply.","title":"Packages description"},{"location":"code-description-and-examples/game/","text":"In this section, the overall architecture of the actual game will be described, together with the reasons behind the decisions that were taken. Game structure Hexagonal architecture The game was developed from scratch because no implementation was found that was properly decoupled from the keyboard and a display. In fact, the game needed to easily communicate with the client code using sockets, and also using the keyboard for testing purposes. The game architecture is therefore centered on this purpose: it heavily relies on the so-called hexagonal architecture as described in this article and on the dependency injection pattern. Game files These are the files implementing the game logic: \u251c\u2500\u2500 ball.py \u251c\u2500\u2500 controller.py \u251c\u2500\u2500 game_rules.py \u2514\u2500\u2500 paddle.py Game objects Ball and paddles The game is object-oriented: ball.py and paddle.py implement the corresponding objects logic, exposing a move() method which updates their state. The ball doesn't need particular inputs because it just implements its physics relatively to the surrounding world, while the paddle takes a command input. Both methods take a time interval that is used to correctly update the objects state according to the amount of time elapsed since the last call. Controller The controller is the true center of the game: it uses constants and definitions in game_rules.py to determine global game rules, and requires external Input and Output classes to work with. It is responsible for handling the ball and the paddles to implement the game. When initialized, it starts a new thread in which the whole logic runs. Input interface The input class is used to take the paddles commands and process them: it needs to provide a left_paddle_input and a right_paddle_input attributes asynchronously. The controller will use their current value during the game loop. Must be thread-safe. Why attributes While attributes may seem arbitrary and limiting some Input implementation choices, the @property methods in Python work as attributes, removing this apparent limitation. Therefore, an implementer can create whatever logic they may feel fit, and the client will use the class cleanly. current_command = input . left_paddle_input # while an attribute, it can execute logic as a method if needed paddle . move ( delta_t , current_command ) Output interface The output class is used by the controller to communicate with the external clients at different times during the execution of the game. It needs to provide: a method init_game ( data : dict ) , called only once at the very start of the game with configuration parameters such as the width of the paddle, the length of the paddle, and the radius of the ball. It therefore signals that the game has started. a __call__ ( data : dict ) implementation which is called once every server tick , receiving game status data as a Python dict . It contains information about the ball and paddles positions, whether the ball has just bounced, the current match time, and other relevant current information. a method end_game ( data : dict ) , called only once to signal the final scores of the two players and the match time. Tip In order to avoid slowing down the game loop, it's best to implement the output class as a thread-safe queue which then gets read somewhere else. Actual input and output implementations Local game In order to test the game and the game only, an input-output implementation was created which used the keyboard presses and the screen. It can be found in the package game/pong/test/ , together with a testing.py module which can be executed stand-alone to test the game locally. Game controls (click to expand) The local game supports two players: the left player should use: W for moving the paddle upwards, S for moving the paddle downwards, Left Shift for accelerating the paddle movements. While the right player should use: Up for moving the paddle upwards, Down for moving the paddle downwards, Right Shift for accelerating the paddle movements. Queue-based In order to use the game from multiple threads correctly, an input-output implementation was created which makes use of a custom CircularQueue class. This thread-safe queue is based on the collections.deque class, can be configured to have a maximum size, after which old elements are replaced with new ones as they are inserted. The queue uses the wait/notify pattern with condition variables in order to expose a blocking get method. While the consumer of the Input queue is the controller itself and the producer is the websocket client, it is now needed a consumer for dequeueing the items in the Output queue inserted by the controller game loop. That is why the game/pong_output_consumer.py module was created. Its responsibility lies in dequeueing messages from the Output and sending them at the Django Channels group of the corresponding match. Then, each websocket will send to its client the message with the game status update. The whole implementation of this is found in game/pong/queue/ . Caution The size of the queues is an important parameter to set. Let's imagine that the server experiences a brief connection problem and, as a consequence, the output queue starts to accumulate items to be sent. It is important that the clients receive the most up-to-date status as possible to be able to play correctly: therefore, dropping some old packets will actually be beneficial to the clients, even if they experience a slight jump in their view of the game. If the queue is too big , this packet drop never happens , and the clients risk living in the past if problems arise. If the queue is too small , packets could be dropped when they could be easily sent in time.","title":"Pong inner workings"},{"location":"code-description-and-examples/game/#game-structure","text":"","title":"Game structure"},{"location":"code-description-and-examples/game/#hexagonal-architecture","text":"The game was developed from scratch because no implementation was found that was properly decoupled from the keyboard and a display. In fact, the game needed to easily communicate with the client code using sockets, and also using the keyboard for testing purposes. The game architecture is therefore centered on this purpose: it heavily relies on the so-called hexagonal architecture as described in this article and on the dependency injection pattern.","title":"Hexagonal architecture"},{"location":"code-description-and-examples/game/#game-files","text":"These are the files implementing the game logic: \u251c\u2500\u2500 ball.py \u251c\u2500\u2500 controller.py \u251c\u2500\u2500 game_rules.py \u2514\u2500\u2500 paddle.py","title":"Game files"},{"location":"code-description-and-examples/game/#game-objects","text":"","title":"Game objects"},{"location":"code-description-and-examples/game/#ball-and-paddles","text":"The game is object-oriented: ball.py and paddle.py implement the corresponding objects logic, exposing a move() method which updates their state. The ball doesn't need particular inputs because it just implements its physics relatively to the surrounding world, while the paddle takes a command input. Both methods take a time interval that is used to correctly update the objects state according to the amount of time elapsed since the last call.","title":"Ball and paddles"},{"location":"code-description-and-examples/game/#controller","text":"The controller is the true center of the game: it uses constants and definitions in game_rules.py to determine global game rules, and requires external Input and Output classes to work with. It is responsible for handling the ball and the paddles to implement the game. When initialized, it starts a new thread in which the whole logic runs.","title":"Controller"},{"location":"code-description-and-examples/game/#actual-input-and-output-implementations","text":"","title":"Actual input and output implementations"},{"location":"code-description-and-examples/rest_api/","text":"Rest API In this section, interesting parts of the REST code will be explored and commented. Models Note Here, only code will be described: for the architecture, head to the database reference . Operating on users in OngoingMatch In the rest_api_ongoingmatch table, information about the currently playing users is not easily accessible. Furthermore, inserting and removing users consists of two operations, requiring both a change of role and of the ongoing_match foreign key of the user. Rather than repeating often-used queries, Python's computed properties were used in order to simulate having hosts, challengers and spectators readily available and modifiable directly in the OngoingMatch instance. This helped to reduce the verbosity of the code, to respect the Don't repeat yourself (DRY) principle and, more importantly, to avoid to forget to change both attributes in the user. 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @property def host ( self ) -> typing . Optional [ User ]: try : return self . user_set . get ( role = User . Role . HOST ) except User . DoesNotExist : return None @host . setter def host ( self , value : User ): if self . host : raise ValueError ( 'Host was already set' ) if value . ongoing_match : raise ValueError ( f 'User {value.username} is already in a match' ) value . ongoing_match = self value . role = User . Role . HOST value . save ( update_fields = [ 'role' , 'ongoing_match' ]) This snippet enables the use of simple syntax for accessing or setting the host of a match as if it were an attribute of the class: user = User . objects . get ( username = 'msilla' ) ongoing_match . host = user print ( ongoing_match . host ) >>> User ( < msilla > ) The setter property also validates the inserting operation, raising ValueError if incompatibilites arise. Code equivalents exist for the challenger and spectator roles, with the only exception being the spectator methods permitting multiple players with the same role. Ending a match In order to complete a match correctly, it is needed to: update the players' ELOs; set the role and the ongoing_match of the players to None ; delete the current OngoingMatch instance from the database; create a corresponding CompletedMatch instance to keep track of the games history. It is very important to conduct all of these operations in a single database transaction, in order to avoid leaving the data in an inconsistent state \u2014 either for brief durations while during the execution, or until human intervention if any errors happen before completing the set of needed operations. This is only one example of such a situation, which demonstrates the use of transactions in the Django Model API. Important In the following snippet, the ongoing_match foreign key is not updated because it is automatically set to NULL by the DBMS due to the configured on_delete policy. 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def complete_match ( self , winner : User , loser : User , winner_score : int , loser_score : int ) -> CompletedMatch : users = [ self . host , self . challenger ] if winner . username == loser . username : raise ValueError ( 'Winner and Loser must be different' ) if ( winner not in users ) or ( loser not in users ): raise ValueError ( 'User not playing the game' ) new_winner_elo , new_loser_elo = compute_elos ( winner , loser , winner_score , loser_score ) with transaction . atomic (): completed_match = CompletedMatch . objects . create ( winner = winner , loser = loser , start_timestamp = self . start_timestamp , winner_score = winner_score , loser_score = loser_score , winner_elo_before_match = winner . elo , loser_elo_before_match = loser . elo , winner_elo_after_match = new_winner_elo , loser_elo_after_match = new_loser_elo ) winner . elo = new_winner_elo loser . elo = new_loser_elo winner . role = None loser . role = None winner . save ( update_fields = [ 'elo' , 'role' ]) loser . save ( update_fields = [ 'elo' , 'role' ]) self . delete () return completed_match Views While much of the views code is straightforward, there are interesting edge cases to take into account. OngoingMatch creation When an OngoingMatch is created by a soon-to-be host via a POST request, it must also be linked to the user that started the request, in order to keep track of the ownership of the match. Therefore, the match instance is created, and then the user must be updated by setting the new instance as the user's current match. If the user is already in a game when making the request, or any unanticipated errors happen after having created the match, the database is left in an inconsistent state; a transaction is necessary to avoid this. 53 54 55 56 57 58 59 60 61 62 def create ( self , request , * args , ** kwargs ): with transaction . atomic (): new_ongoing_match = OngoingMatch . objects . create () try : new_ongoing_match . host = request . user except ValueError as e : raise serializers . ValidationError ( str ( e )) serializer = OngoingMatchSerializer ( instance = new_ongoing_match ) return Response ( serializer . data , status = status . HTTP_201_CREATED ) This code structure enforces a rollback of the database operations if any errors occur, while alerting the user. Otherwise, a normal HTTP 201 response is returned together with the new object representation in the body, respecting REST design principles. Clean views No substantial logic is therefore executed in the views, which only glue together other code: the error validation is done inside the model (just as described in the previous section ), the serialization of the new instance to a Python dict is handled by the serializer, and the JSON serialization is made by the Response internal handlers.","title":"REST API"},{"location":"code-description-and-examples/rest_api/#rest-api","text":"In this section, interesting parts of the REST code will be explored and commented.","title":"Rest API"},{"location":"code-description-and-examples/rest_api/#models","text":"Note Here, only code will be described: for the architecture, head to the database reference .","title":"Models"},{"location":"code-description-and-examples/rest_api/#operating-on-users-in-ongoingmatch","text":"In the rest_api_ongoingmatch table, information about the currently playing users is not easily accessible. Furthermore, inserting and removing users consists of two operations, requiring both a change of role and of the ongoing_match foreign key of the user. Rather than repeating often-used queries, Python's computed properties were used in order to simulate having hosts, challengers and spectators readily available and modifiable directly in the OngoingMatch instance. This helped to reduce the verbosity of the code, to respect the Don't repeat yourself (DRY) principle and, more importantly, to avoid to forget to change both attributes in the user. 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @property def host ( self ) -> typing . Optional [ User ]: try : return self . user_set . get ( role = User . Role . HOST ) except User . DoesNotExist : return None @host . setter def host ( self , value : User ): if self . host : raise ValueError ( 'Host was already set' ) if value . ongoing_match : raise ValueError ( f 'User {value.username} is already in a match' ) value . ongoing_match = self value . role = User . Role . HOST value . save ( update_fields = [ 'role' , 'ongoing_match' ]) This snippet enables the use of simple syntax for accessing or setting the host of a match as if it were an attribute of the class: user = User . objects . get ( username = 'msilla' ) ongoing_match . host = user print ( ongoing_match . host ) >>> User ( < msilla > ) The setter property also validates the inserting operation, raising ValueError if incompatibilites arise. Code equivalents exist for the challenger and spectator roles, with the only exception being the spectator methods permitting multiple players with the same role.","title":"Operating on users in OngoingMatch"},{"location":"code-description-and-examples/rest_api/#ending-a-match","text":"In order to complete a match correctly, it is needed to: update the players' ELOs; set the role and the ongoing_match of the players to None ; delete the current OngoingMatch instance from the database; create a corresponding CompletedMatch instance to keep track of the games history. It is very important to conduct all of these operations in a single database transaction, in order to avoid leaving the data in an inconsistent state \u2014 either for brief durations while during the execution, or until human intervention if any errors happen before completing the set of needed operations. This is only one example of such a situation, which demonstrates the use of transactions in the Django Model API. Important In the following snippet, the ongoing_match foreign key is not updated because it is automatically set to NULL by the DBMS due to the configured on_delete policy. 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def complete_match ( self , winner : User , loser : User , winner_score : int , loser_score : int ) -> CompletedMatch : users = [ self . host , self . challenger ] if winner . username == loser . username : raise ValueError ( 'Winner and Loser must be different' ) if ( winner not in users ) or ( loser not in users ): raise ValueError ( 'User not playing the game' ) new_winner_elo , new_loser_elo = compute_elos ( winner , loser , winner_score , loser_score ) with transaction . atomic (): completed_match = CompletedMatch . objects . create ( winner = winner , loser = loser , start_timestamp = self . start_timestamp , winner_score = winner_score , loser_score = loser_score , winner_elo_before_match = winner . elo , loser_elo_before_match = loser . elo , winner_elo_after_match = new_winner_elo , loser_elo_after_match = new_loser_elo ) winner . elo = new_winner_elo loser . elo = new_loser_elo winner . role = None loser . role = None winner . save ( update_fields = [ 'elo' , 'role' ]) loser . save ( update_fields = [ 'elo' , 'role' ]) self . delete () return completed_match","title":"Ending a match"},{"location":"code-description-and-examples/rest_api/#views","text":"While much of the views code is straightforward, there are interesting edge cases to take into account.","title":"Views"},{"location":"code-description-and-examples/rest_api/#ongoingmatch-creation","text":"When an OngoingMatch is created by a soon-to-be host via a POST request, it must also be linked to the user that started the request, in order to keep track of the ownership of the match. Therefore, the match instance is created, and then the user must be updated by setting the new instance as the user's current match. If the user is already in a game when making the request, or any unanticipated errors happen after having created the match, the database is left in an inconsistent state; a transaction is necessary to avoid this. 53 54 55 56 57 58 59 60 61 62 def create ( self , request , * args , ** kwargs ): with transaction . atomic (): new_ongoing_match = OngoingMatch . objects . create () try : new_ongoing_match . host = request . user except ValueError as e : raise serializers . ValidationError ( str ( e )) serializer = OngoingMatchSerializer ( instance = new_ongoing_match ) return Response ( serializer . data , status = status . HTTP_201_CREATED ) This code structure enforces a rollback of the database operations if any errors occur, while alerting the user. Otherwise, a normal HTTP 201 response is returned together with the new object representation in the body, respecting REST design principles. Clean views No substantial logic is therefore executed in the views, which only glue together other code: the error validation is done inside the model (just as described in the previous section ), the serialization of the new instance to a Python dict is handled by the serializer, and the JSON serialization is made by the Response internal handlers.","title":"OngoingMatch creation"},{"location":"external-dependencies/","text":"Overview Topics external to the course are described in this section. Django Django is a Python web framework aimed at providing much of the usual boilerplate code as built-in directly out of the box. For what concerns this project, it provided easy management of a database through the Django Object Relational Mapping (ORM) , registration of users, session management, multithreaded request handling. In particular, the ORM was extremely useful to easily create and handle database changes Django REST framework Token authentication Django channels Websockets","title":"External dependencies"},{"location":"external-dependencies/#overview","text":"Topics external to the course are described in this section.","title":"Overview"},{"location":"external-dependencies/#django","text":"Django is a Python web framework aimed at providing much of the usual boilerplate code as built-in directly out of the box. For what concerns this project, it provided easy management of a database through the Django Object Relational Mapping (ORM) , registration of users, session management, multithreaded request handling. In particular, the ORM was extremely useful to easily create and handle database changes","title":"Django"},{"location":"external-dependencies/#django-rest-framework","text":"","title":"Django REST framework"},{"location":"external-dependencies/#django-channels","text":"","title":"Django channels"},{"location":"interfaces/REST_API/","text":"REST API Overview This section shows the list of all the resources available in the LHobby REST API. Some endpoints require authentication. Authentication If you see this icon, the endpoint requires authentication. If you see this icon, the endpoint does not require authentication. Authentication There are two ways to do an authenticated request. Token : if you have an authentication token you can do an authenticated request using the header key Authorization with Token <authentication token> as value. Cookie : if you are using a browser you can authenticate via the Cookie header key. Cookie based login Login into the system. This endpoint is better suited for browser clients. post /HOST:PORT/api/login/ Parameters Name Type In Description Required username string body true password string body true next string param the url you will be redirected to false OK response Status: 302 Found Cookie based logout Logout from the system. This endpoint is better suited for browser clients. post /HOST:PORT/api/logout/ Parameters Name Type In Description Required Cookie string header session cookie for authentication true OK response Status: 200 OK Get authorization token Use this endpoint to generate a token for the authentication. post /HOST:PORT/api/token/ Parameters Name Type In Description Required username string body true password string body true OK response Status: 200 OK { \"token\" : \"b8a60e83569600e8f5c323428cca736ce9176e0f\" } Delete authorization token Use this endpoint to delete a specific user token. delete /HOST:PORT/api/token/ Parameters Name Type In Description Required Authorization string header token for authentication, it must be in this form: Token true Response Status: 204 No Content API Reference Create a new user It allows to create a new user. post /HOST:PORT/api/users/sign_up/ Parameters Name Type In Description Required username string body the username of the user true password string body the password must contain at least 8 characters and it must not be too similar to the username true email string body user email false first_name string body user first name false last_name string body user last name false Created response Status: 201 Created { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : null , \"role\" : null , \"first_name\" : \"\" , \"last_name\" : \"\" } List users List all registered users. get /HOST:PORT/api/users/ Parameters Name Type In Description Required ordering string param if equal to one in [elo, -elo, username, -username] the user list will be ordered false OK response Status: 200 OK [ { \"username\" : \"emanuele\" , \"date_joined\" : \"2021-01-15T23:17:32.966236Z\" , \"elo\" : 900 , \"ongoing_match\" : 40 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, { \"username\" : \"davide\" , \"date_joined\" : \"2021-01-15T23:18:11.368676Z\" , \"elo\" : 1000 , \"ongoing_match\" : null , \"role\" : null , \"first_name\" : \"\" , \"last_name\" : \"\" }, { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : null , \"role\" : null , \"first_name\" : \"\" , \"last_name\" : \"\" } ] User detail Get detail of specific user using his username . get /HOST:PORT/api/users/{username}/ Parameters Name Type In Description Required username string path true OK response Status: 200 OK { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : null , \"role\" : null , \"first_name\" : \"\" , \"last_name\" : \"\" } Ongoing match of a specific user Get the ongoing match of a specific user. get /HOST:PORT/api/users/{username}/ongoing_match/ Parameters Name Type In Description Required username string path true OK response Status: 200 OK { \"id\" : 40 , \"host\" : { \"username\" : \"emanuele\" , \"date_joined\" : \"2021-01-15T23:17:32.966236Z\" , \"elo\" : 900 , \"ongoing_match\" : 40 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : null , \"creation_timestamp\" : \"2021-01-18T18:34:09.576490Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false } Create a new ongoing match It allows to create a new match for the authenticated user, setting them as host of the match. post /HOST:PORT/api/ongoing_matches/ Created response Status: 201 Created { \"id\" : 41 , \"host\" : { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : null , \"creation_timestamp\" : \"2021-01-19T09:56:45.727233Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false } Warning The user must not be already playing or spectating another match, otherwise the following response will be returned: Status: 400 Bad Request [ \"User davide is already in a match\" ] List ongoing matches List all ongoing matches. get /HOST:PORT/api/ongoing_matches/ Parameters Name Type In Description Required ordering string param if equal to one in [host_elo, -host_elo] the ongoing match list will be ordered false is_full bool param if true, only the matches that already have a challenger will be returned, otherwise the ones without a challenger false max_elo number param if given, the ongoing matches hosted by an user with an elo greater than max_elo will not be returned false min_elo number param if given the the ongoing matches hosted by an user with an elo less than min_elo will not be returned false OK response Status: 200 OK [ { \"id\" : 40 , \"host\" : { \"username\" : \"emanuele\" , \"date_joined\" : \"2021-01-15T23:17:32.966236Z\" , \"elo\" : 900 , \"ongoing_match\" : 40 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : null , \"creation_timestamp\" : \"2021-01-18T18:34:09.576490Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false }, { \"id\" : 41 , \"host\" : { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : { \"username\" : \"davide\" , \"date_joined\" : \"2021-01-15T23:18:11.368676Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"C\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"creation_timestamp\" : \"2021-01-19T09:56:45.727233Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false } ] Ongoing match detail Get detail of a specific ongoing match using his id . get /HOST:PORT/api/ongoing_matches/{id}/ Parameters Name Type In Description Required id string path id number of the ongoing match true OK response Status: 200 OK { \"id\" : 41 , \"host\" : { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : { \"username\" : \"davide\" , \"date_joined\" : \"2021-01-15T23:18:11.368676Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"C\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"creation_timestamp\" : \"2021-01-19T09:56:45.727233Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false } Delete specific ongoing match Delete a specific ongoing match given the match id . delete /HOST:PORT/api/ongoing_matches/{id}/ Note An ongoing match can be deleted only from its host and only if it is not started yet. Parameters Name Type In Description Required id string path id number of the ongoing match to delete true Response Status: 204 No Content Ongoing match user detail Get detail of the host, the challenger or the spectators of a specific match. get /HOST:PORT/api/ongoing_matches/{id}/{role}/ Parameters Name Type In Description Required id string path id number of the ongoing match true role string path choose one in [host, challenger, spectators] true OK response Status: 200 OK { \"username\" : \"davide\" , \"date_joined\" : \"2021-01-15T23:18:11.368676Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"C\" , \"first_name\" : \"\" , \"last_name\" : \"\" } Creation of a completed match Completed matches are only automatically generated after the end of an ongoing match. List completed matches List all completed matches. get /HOST:PORT/api/completed_matches/ Parameters Name Type In Description Required ordering string param if equal to one in [id, winner, loser, start_timestamp, end_timestamp, completion_timestamp, winner_score, loser_score, winner_elo_before_match, winner_elo_after_match, loser_elo_before_match, loser_elo_after_match] the ongoing match list will be ordered. Put a ' - ' before the ordering type for descending order false winner string param filter completed matches with a specific winner false loser string param filter completed matches with a specific loser false user string param filter completed matches with a specific user, it is not important if it is a winner or a loser false end_timestamp_after datetime param the matches completed before the passed parameter will not be returned false end_timestamp_before datetime param the matches completed after the passed parameter will not be returned false Note datetime parameters must be formatted as: yy:mm:dd OK response Status: 200 OK [ { \"id\" : 1 , \"winner\" : \"davide\" , \"loser\" : \"emanuele\" , \"start_timestamp\" : \"2021-01-16T16:40:51.981401Z\" , \"completion_timestamp\" : \"2021-01-16T16:41:20.669025Z\" , \"winner_score\" : 5 , \"loser_score\" : 4 , \"winner_elo_before_match\" : 1000 , \"loser_elo_before_match\" : 1000 , \"winner_elo_after_match\" : 1050 , \"loser_elo_after_match\" : 950 } ] Completed match detail Get detail of specific completed match using his id . get /HOST:PORT/api/completed_matches/{id}/ Parameters Name Type In Description Required id string path id number of the completed match true OK response Status: 200 OK { \"id\" : 1 , \"winner\" : \"davide\" , \"loser\" : \"emanuele\" , \"start_timestamp\" : \"2021-01-16T16:40:51.981401Z\" , \"completion_timestamp\" : \"2021-01-16T16:41:20.669025Z\" , \"winner_score\" : 5 , \"loser_score\" : 4 , \"winner_elo_before_match\" : 1000 , \"loser_elo_before_match\" : 1000 , \"winner_elo_after_match\" : 1050 , \"loser_elo_after_match\" : 950 }","title":"REST API"},{"location":"interfaces/REST_API/#rest-api","text":"","title":"REST API"},{"location":"interfaces/REST_API/#overview","text":"This section shows the list of all the resources available in the LHobby REST API. Some endpoints require authentication. Authentication If you see this icon, the endpoint requires authentication. If you see this icon, the endpoint does not require authentication.","title":"Overview"},{"location":"interfaces/REST_API/#authentication","text":"There are two ways to do an authenticated request. Token : if you have an authentication token you can do an authenticated request using the header key Authorization with Token <authentication token> as value. Cookie : if you are using a browser you can authenticate via the Cookie header key.","title":"Authentication"},{"location":"interfaces/REST_API/#cookie-based-login","text":"Login into the system. This endpoint is better suited for browser clients. post /HOST:PORT/api/login/","title":" Cookie based login"},{"location":"interfaces/REST_API/#cookie-based-logout","text":"Logout from the system. This endpoint is better suited for browser clients. post /HOST:PORT/api/logout/","title":" Cookie based logout"},{"location":"interfaces/REST_API/#get-authorization-token","text":"Use this endpoint to generate a token for the authentication. post /HOST:PORT/api/token/","title":" Get authorization token"},{"location":"interfaces/REST_API/#delete-authorization-token","text":"Use this endpoint to delete a specific user token. delete /HOST:PORT/api/token/","title":" Delete authorization token"},{"location":"interfaces/REST_API/#api-reference","text":"","title":"API Reference"},{"location":"interfaces/REST_API/#create-a-new-user","text":"It allows to create a new user. post /HOST:PORT/api/users/sign_up/","title":" Create a new user"},{"location":"interfaces/REST_API/#list-users","text":"List all registered users. get /HOST:PORT/api/users/","title":" List users"},{"location":"interfaces/REST_API/#user-detail","text":"Get detail of specific user using his username . get /HOST:PORT/api/users/{username}/","title":" User detail"},{"location":"interfaces/REST_API/#ongoing-match-of-a-specific-user","text":"Get the ongoing match of a specific user. get /HOST:PORT/api/users/{username}/ongoing_match/","title":" Ongoing match of a specific user"},{"location":"interfaces/REST_API/#create-a-new-ongoing-match","text":"It allows to create a new match for the authenticated user, setting them as host of the match. post /HOST:PORT/api/ongoing_matches/","title":" Create a new ongoing match"},{"location":"interfaces/REST_API/#list-ongoing-matches","text":"List all ongoing matches. get /HOST:PORT/api/ongoing_matches/","title":" List ongoing matches"},{"location":"interfaces/REST_API/#ongoing-match-detail","text":"Get detail of a specific ongoing match using his id . get /HOST:PORT/api/ongoing_matches/{id}/","title":" Ongoing match detail"},{"location":"interfaces/REST_API/#delete-specific-ongoing-match","text":"Delete a specific ongoing match given the match id . delete /HOST:PORT/api/ongoing_matches/{id}/ Note An ongoing match can be deleted only from its host and only if it is not started yet.","title":" Delete specific ongoing match"},{"location":"interfaces/REST_API/#ongoing-match-user-detail","text":"Get detail of the host, the challenger or the spectators of a specific match. get /HOST:PORT/api/ongoing_matches/{id}/{role}/","title":" Ongoing match user detail"},{"location":"interfaces/REST_API/#creation-of-a-completed-match","text":"Completed matches are only automatically generated after the end of an ongoing match.","title":"Creation of a completed match"},{"location":"interfaces/REST_API/#list-completed-matches","text":"List all completed matches. get /HOST:PORT/api/completed_matches/","title":" List completed matches"},{"location":"interfaces/REST_API/#completed-match-detail","text":"Get detail of specific completed match using his id . get /HOST:PORT/api/completed_matches/{id}/","title":" Completed match detail"},{"location":"interfaces/websockets/","text":"Websockets Overview This section shows the communication protocol between a client and the websocket server. The possible messages are related to the game phase and to the role of the client in the match. The client must be authenticated to communicate with the server. Protocol description Initialization phase First of all the client should start the communication with the server. In this phase the user must specify the role and the id of the match to join. In order to start the communication, the client must open a websocket connection using the following url: ws://HOST:PORT/ws/game/{match_id}/?role={role} If the websocket request is not acceptable by the server, these are the possible error messages: The match ID is not a number or is not present in the request: { \"type\" : \"websocket.close\" , \"code\" : 4000 } The user is not authenticated: { \"type\" : \"websocket.close\" , \"code\" : 4001 } The query string contains more than one parameter or is not well formed: { \"type\" : \"websocket.close\" , \"code\" : 4000 } The requested role is not in [host, challenger, spectator] : { \"type\" : \"websocket.close\" , \"code\" : 4000 } The client requested to be a spectator or a challenger but is already in a match: { \"type\" : \"websocket.close\" , \"code\" : 4000 } The client is an host of a match but the match he wants to join is another one: { \"type\" : \"websocket.close\" , \"code\" : 4003 } Finally, if everything is ok for the server, the connection is established, and the client receives: { \"type\" : \"websocket.accept\" } Host Challenger Spectator","title":"Websockets"},{"location":"interfaces/websockets/#websockets","text":"","title":"Websockets"},{"location":"interfaces/websockets/#overview","text":"This section shows the communication protocol between a client and the websocket server. The possible messages are related to the game phase and to the role of the client in the match. The client must be authenticated to communicate with the server.","title":"Overview"},{"location":"interfaces/websockets/#protocol-description","text":"","title":"Protocol description"},{"location":"interfaces/websockets/#initialization-phase","text":"First of all the client should start the communication with the server. In this phase the user must specify the role and the id of the match to join. In order to start the communication, the client must open a websocket connection using the following url: ws://HOST:PORT/ws/game/{match_id}/?role={role} If the websocket request is not acceptable by the server, these are the possible error messages: The match ID is not a number or is not present in the request: { \"type\" : \"websocket.close\" , \"code\" : 4000 } The user is not authenticated: { \"type\" : \"websocket.close\" , \"code\" : 4001 } The query string contains more than one parameter or is not well formed: { \"type\" : \"websocket.close\" , \"code\" : 4000 } The requested role is not in [host, challenger, spectator] : { \"type\" : \"websocket.close\" , \"code\" : 4000 } The client requested to be a spectator or a challenger but is already in a match: { \"type\" : \"websocket.close\" , \"code\" : 4000 } The client is an host of a match but the match he wants to join is another one: { \"type\" : \"websocket.close\" , \"code\" : 4003 } Finally, if everything is ok for the server, the connection is established, and the client receives: { \"type\" : \"websocket.accept\" }","title":"Initialization phase"},{"location":"introduction/","text":"LHobby Scope This documentation describes the development of the final project for the Distributed Programming class 2020/21 of University of Salerno. It is intended to demonstrate and put to practice the knowledge acquired during the course. Group This project was made by group 7, composed by: Name ID E-mail Davide Cafaro 0622701062 d.cafaro4@studenti.unisa.it Emanuele D'Arminio 0622701059 e.darminio4@studenti.unisa.it Marta Silla 0622701337 m.silla@studenti.unisa.it Overview LHobby is a distributed platform that lets users challenge their friends in a real time multiplayer game: Pong . The platforms keeps track of users past matches and progress, allowing competition among players. It is possible to create or join a match as player or spectator, and after the game check the platform-wide leaderboard. Since the platform makes use of language agnostic protocols, it is possible to link cross-platform clients to it. Navigating the docs todo","title":"LHobby"},{"location":"introduction/#lhobby","text":"","title":"LHobby"},{"location":"introduction/#scope","text":"This documentation describes the development of the final project for the Distributed Programming class 2020/21 of University of Salerno. It is intended to demonstrate and put to practice the knowledge acquired during the course.","title":"Scope"},{"location":"introduction/#group","text":"This project was made by group 7, composed by: Name ID E-mail Davide Cafaro 0622701062 d.cafaro4@studenti.unisa.it Emanuele D'Arminio 0622701059 e.darminio4@studenti.unisa.it Marta Silla 0622701337 m.silla@studenti.unisa.it","title":"Group"},{"location":"introduction/#overview","text":"LHobby is a distributed platform that lets users challenge their friends in a real time multiplayer game: Pong . The platforms keeps track of users past matches and progress, allowing competition among players. It is possible to create or join a match as player or spectator, and after the game check the platform-wide leaderboard. Since the platform makes use of language agnostic protocols, it is possible to link cross-platform clients to it.","title":"Overview"},{"location":"introduction/#navigating-the-docs","text":"todo","title":"Navigating the docs"},{"location":"introduction/installation/","text":"Installation","title":"Installation"},{"location":"introduction/installation/#installation","text":"","title":"Installation"},{"location":"introduction/usage/","text":"Usage","title":"Usage"},{"location":"introduction/usage/#usage","text":"","title":"Usage"}]}