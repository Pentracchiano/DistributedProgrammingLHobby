{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LHobby \u00b6 Scope \u00b6 This documentation describes the development of the final project for the Distributed Programming class 2020/21 of University of Salerno. The project intends to demonstrate and put to practice the knowledge acquired during the course. Group \u00b6 This project was made by group 7, composed by: Name ID E-mail Davide Cafaro 0622701062 d.cafaro4@studenti.unisa.it Emanuele D'Arminio 0622701059 e.darminio4@studenti.unisa.it Marta Silla 0622701337 m.silla@studenti.unisa.it Overview \u00b6 LHobby is a distributed platform that lets users challenge their friends in a real time multiplayer game: Pong . The platforms keeps track of users past matches and progress, allowing competition among players. It is possible to create or join a match as player or spectator, and after the game check the platform-wide leaderboard. Since the platform makes use of language agnostic protocols, it is possible to link cross-platform clients to it. Check how to get started and install LHobby in the next section.","title":"LHobby"},{"location":"#lhobby","text":"","title":"LHobby"},{"location":"#scope","text":"This documentation describes the development of the final project for the Distributed Programming class 2020/21 of University of Salerno. The project intends to demonstrate and put to practice the knowledge acquired during the course.","title":"Scope"},{"location":"#group","text":"This project was made by group 7, composed by: Name ID E-mail Davide Cafaro 0622701062 d.cafaro4@studenti.unisa.it Emanuele D'Arminio 0622701059 e.darminio4@studenti.unisa.it Marta Silla 0622701337 m.silla@studenti.unisa.it","title":"Group"},{"location":"#overview","text":"LHobby is a distributed platform that lets users challenge their friends in a real time multiplayer game: Pong . The platforms keeps track of users past matches and progress, allowing competition among players. It is possible to create or join a match as player or spectator, and after the game check the platform-wide leaderboard. Since the platform makes use of language agnostic protocols, it is possible to link cross-platform clients to it. Check how to get started and install LHobby in the next section.","title":"Overview"},{"location":"architecture/","text":"Architecture overview \u00b6 The system is structured as a client-server architecture. Clients communicate with the server using a server API and websocket connections. The server makes use of a database to store information about the users and the matches. Cross-platform support Since the architecture only makes use of language agnostic protocols, such as HTTP and Websocket, clients are free to be implemented independently of the language or platform. Diagram \u00b6 The following diagram provides an abstract overall outline of the entities in the system and the relationship between them, presenting an example of a use case of the system. Database \u00b6 The system's server makes use of a database in order to keep track of the information required for the correct functioning of the platform. The different kind of information are stored in separate SQL tables, which are: rest_api_user - Stores different information about the users. rest_api_ongoingmatch - Stores information about ongoing matches. rest_api_completedmatch - Stores information about completed matches. authtoken_token - Stores tokens and relative users. Users \u00b6 The system stores the following login information in order to let them register to the platform and keep track of their progress. username - Unique username associated to the player required to log in. password - Password established at registration time, required to log in. Passwords are hashed using PBKDF2 as to preserve the privacy of the users. email - E-mail address associated to the account. Other information concerning the gaming state of the user is stored, such as: ongoing_match_id - Containing the unique identifier of the match in which the user is participating, if playing, otherwise <null> . role - Containing information about the role of the player, if associated to an ongoing match. The different possible roles are: host , challenger , spectator . Fields carrying other generic information about the user are: elo - Rating score indicating the skill level of the player. date_joined - Date and time of the registration of the user. last_login - Date and time of the last log in of the user. Here follows an example of the rest_api_user database table. id password last_login username email date_joined role ongoing_match_id elo 1 pbkdf2_sha256$... 2021-01-18 18:00:00 davide d.cafaro4@studenti.unisa.it 2021-01-18 H 3 1000 2 pbkdf2_sha256$... 2021-01-18 18:00:00 emanuele e.darminio4@studenti.unisa.it 2021-01-18 C 3 1000 3 pbkdf2_sha256$... 2021-01-18 18:00:00 marta m.silla@studenti.unisa.it 2021-01-18 S 3 1000 Ongoing matches \u00b6 To correctly link players and spectators to the same match and synchronize their gaming status, each user keeps a reference to the relative ongoing match. The list of ongoing matches is stored in the database. Each entry contains the following fields: id - Unique identifier of the match. creation_timestamp - Date and time of the creation of the match by the host. start_timestamp - Date and time of the start of the match. is_started - Boolean value used to know whether the game has started. is_challenger_ready - Boolean value used to alert the host that the challenger is ready. Here follows an example of the rest_api_ongoing_matches database table. id creation_timestamp start_timestamp is_started is_challenger_ready 3 2021-01-18 18:48:00 2021-01-18 18:50:00 1 1 Completed matches \u00b6 When a match is completed the system stores its relative information, along with the players scores and elos, in order to keep track of their progress. id start_timestamp completion_timestamp loser_id winner_id loser_elo_after_match loser_elo_before_match loser_score winner_elo_after_match winner_elo_before_match winner_score 1 2021-01-18 18:18:00 2021-01-18 18:30:00 1 2 950 1000 4 1050 1000 5 2 2021-01-18 18:28:00 2021-01-18 18:40:00 2 1 1000 1050 4 950 1000 5 Constraints To preserve the accuracy and the reliability of the data in the database, additional constraints are specified for SQL tables containing information about matches. Loser ID and winner ID must be different, the score of the winner must be higher than the score of the loser and the elo of the player must be coherently increased in case of victory and decreased in case of defeat. Also completion time must be subsequent to start time. Tokens \u00b6 The token based authentication provided by the Django REST framework is used to allow users to verify their identity. After the registration of a new user, the login function returns the token associated with the user. This token is then used to access the authenticated API. In order to verify the identity of the user, tokens are stored in a SQL table and associated with the corresponding user ID as follows: key created user_id fd726egydgnf75g... 2021-01-18 18:00:00 1 9h87ydb8ag8hjg6... 2021-01-18 18:00:00 2 uhdsa8dadh1hgf5... 2021-01-18 18:00:00 3 Server \u00b6 API Users can register to the platform through the server API. Once authenticated, users can access the list of registered users, ongoing matches and completed matches. Through a POST operation on the server API, users can create a new ongoing match, for which they'll assume the role of host. The server returns the ID of the match. For further detail, check the REST API section . WebSockets Potential challengers and spectators can access the list of ongoing matches through the API server and thus establish a websocket connection with the server specifying the ID of the match and their role. Server handles websocket protocol requests during the game and updates the clients about the state of the match. For further detail, check the websocket section . Client \u00b6 Clients interact both with the API and the Websocket server. After the connection is established and both players are ready, the clients can start a session and begin exchanging information with the server through the sockets. The nature of the exchanged messages depends on the role of the client. After creating a new ongoing match, hosts shall wait for an available challenger. Challengers can join an ongoing match and signal they're ready to play. When the challenger is ready, the host can tart the match. Through the duration of the match, the players can use the socket to send commands to the server so it can update the state of the game. The commands can be: up , down , fast up , fast down . The game ends when one of the players reaches the maximum score and the match results are stored in the database.","title":"Architecture overview"},{"location":"architecture/#architecture-overview","text":"The system is structured as a client-server architecture. Clients communicate with the server using a server API and websocket connections. The server makes use of a database to store information about the users and the matches. Cross-platform support Since the architecture only makes use of language agnostic protocols, such as HTTP and Websocket, clients are free to be implemented independently of the language or platform.","title":"Architecture overview"},{"location":"architecture/#diagram","text":"The following diagram provides an abstract overall outline of the entities in the system and the relationship between them, presenting an example of a use case of the system.","title":"Diagram"},{"location":"architecture/#database","text":"The system's server makes use of a database in order to keep track of the information required for the correct functioning of the platform. The different kind of information are stored in separate SQL tables, which are: rest_api_user - Stores different information about the users. rest_api_ongoingmatch - Stores information about ongoing matches. rest_api_completedmatch - Stores information about completed matches. authtoken_token - Stores tokens and relative users.","title":"Database"},{"location":"architecture/#users","text":"The system stores the following login information in order to let them register to the platform and keep track of their progress. username - Unique username associated to the player required to log in. password - Password established at registration time, required to log in. Passwords are hashed using PBKDF2 as to preserve the privacy of the users. email - E-mail address associated to the account. Other information concerning the gaming state of the user is stored, such as: ongoing_match_id - Containing the unique identifier of the match in which the user is participating, if playing, otherwise <null> . role - Containing information about the role of the player, if associated to an ongoing match. The different possible roles are: host , challenger , spectator . Fields carrying other generic information about the user are: elo - Rating score indicating the skill level of the player. date_joined - Date and time of the registration of the user. last_login - Date and time of the last log in of the user. Here follows an example of the rest_api_user database table. id password last_login username email date_joined role ongoing_match_id elo 1 pbkdf2_sha256$... 2021-01-18 18:00:00 davide d.cafaro4@studenti.unisa.it 2021-01-18 H 3 1000 2 pbkdf2_sha256$... 2021-01-18 18:00:00 emanuele e.darminio4@studenti.unisa.it 2021-01-18 C 3 1000 3 pbkdf2_sha256$... 2021-01-18 18:00:00 marta m.silla@studenti.unisa.it 2021-01-18 S 3 1000","title":"Users"},{"location":"architecture/#ongoing-matches","text":"To correctly link players and spectators to the same match and synchronize their gaming status, each user keeps a reference to the relative ongoing match. The list of ongoing matches is stored in the database. Each entry contains the following fields: id - Unique identifier of the match. creation_timestamp - Date and time of the creation of the match by the host. start_timestamp - Date and time of the start of the match. is_started - Boolean value used to know whether the game has started. is_challenger_ready - Boolean value used to alert the host that the challenger is ready. Here follows an example of the rest_api_ongoing_matches database table. id creation_timestamp start_timestamp is_started is_challenger_ready 3 2021-01-18 18:48:00 2021-01-18 18:50:00 1 1","title":"Ongoing matches"},{"location":"architecture/#completed-matches","text":"When a match is completed the system stores its relative information, along with the players scores and elos, in order to keep track of their progress. id start_timestamp completion_timestamp loser_id winner_id loser_elo_after_match loser_elo_before_match loser_score winner_elo_after_match winner_elo_before_match winner_score 1 2021-01-18 18:18:00 2021-01-18 18:30:00 1 2 950 1000 4 1050 1000 5 2 2021-01-18 18:28:00 2021-01-18 18:40:00 2 1 1000 1050 4 950 1000 5 Constraints To preserve the accuracy and the reliability of the data in the database, additional constraints are specified for SQL tables containing information about matches. Loser ID and winner ID must be different, the score of the winner must be higher than the score of the loser and the elo of the player must be coherently increased in case of victory and decreased in case of defeat. Also completion time must be subsequent to start time.","title":"Completed matches"},{"location":"architecture/#tokens","text":"The token based authentication provided by the Django REST framework is used to allow users to verify their identity. After the registration of a new user, the login function returns the token associated with the user. This token is then used to access the authenticated API. In order to verify the identity of the user, tokens are stored in a SQL table and associated with the corresponding user ID as follows: key created user_id fd726egydgnf75g... 2021-01-18 18:00:00 1 9h87ydb8ag8hjg6... 2021-01-18 18:00:00 2 uhdsa8dadh1hgf5... 2021-01-18 18:00:00 3","title":"Tokens"},{"location":"architecture/#server","text":"","title":"Server"},{"location":"architecture/#client","text":"Clients interact both with the API and the Websocket server. After the connection is established and both players are ready, the clients can start a session and begin exchanging information with the server through the sockets. The nature of the exchanged messages depends on the role of the client. After creating a new ongoing match, hosts shall wait for an available challenger. Challengers can join an ongoing match and signal they're ready to play. When the challenger is ready, the host can tart the match. Through the duration of the match, the players can use the socket to send commands to the server so it can update the state of the game. The commands can be: up , down , fast up , fast down . The game ends when one of the players reaches the maximum score and the match results are stored in the database.","title":"Client"},{"location":"code-description-and-examples/","text":"The code is organized in Python packages as below. The highlighted packages are the most interesting packages - that is, containing most of the logic of the project. Directory tree \u251c\u2500\u2500 DistributedProgrammingLHobby \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 asgi.py \u2502 \u251c\u2500\u2500 settings.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 wsgi.py \u251c\u2500\u2500 docs-src \u2502 \u251c\u2500\u2500 markdown \u2502 \u2502 \u251c\u2500\u2500 ... (these documentation files as markdown sources) \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 ... (these HTML files) \u251c\u2500\u2500 game \u2502 \u251c\u2500\u2500 authentication \u2502 \u2502 \u2514\u2500\u2500 token.py \u2502 \u251c\u2500\u2500 pong \u2502 \u2502 \u251c\u2500\u2500 queue \u2502 \u2502 \u2502 \u251c\u2500\u2500 circular_queue.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 input.py \u2502 \u2502 \u2502 \u2514\u2500\u2500 output.py \u2502 \u2502 \u251c\u2500\u2500 test \u2502 \u2502 \u2502 \u251c\u2500\u2500 input.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 output.py \u2502 \u2502 \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u2502 \u2502 \u2514\u2500\u2500 testing.py \u2502 \u2502 \u251c\u2500\u2500 ball.py \u2502 \u2502 \u251c\u2500\u2500 controller.py \u2502 \u2502 \u251c\u2500\u2500 game_rules.py \u2502 \u2502 \u2514\u2500\u2500 paddle.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 apps.py \u2502 \u251c\u2500\u2500 consumers.py \u2502 \u251c\u2500\u2500 pong_output_consumer.py \u2502 \u2514\u2500\u2500 routing.py \u251c\u2500\u2500 rest_api \u2502 \u251c\u2500\u2500 migrations \u2502 \u2502 \u251c\u2500\u2500 ... (database migration files) \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 apps.py \u2502 \u251c\u2500\u2500 filters.py \u2502 \u251c\u2500\u2500 models.py \u2502 \u251c\u2500\u2500 serializers.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 views.py \u251c\u2500\u2500 client \u2502 \u251c\u2500\u2500 pygame_client.py \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u2514\u2500\u2500 retro.ttf \u251c\u2500\u2500 db.sqlite3 \u251c\u2500\u2500 manage.py \u2514\u2500\u2500 requirements.txt Packages description \u00b6 DistributedProgrammingLHobby is the Django site directory, containing global settings for the whole server application. In particular, here it is defined: the HTTP handler (the rest_api package), the Websockets handler (the game package), the DBMS (SQLite3), the Django Channels channel_layer (a local Redis instance \u2014 a powerful engine was required for the game to be correctly handled in real-time with multiple connected users), supported authentication methods (token-auth aimed at stand-alone clients and cookie-based aimed at browser clients). docs is the package containing the Markdown files and the custom styles of this documentation, built with the Mkdocs static-site engine. game is responsible for handling the Websocket protocol requests, running the actual games using the code in the pong module, updating clients on the state of the game, and changing the database according to the match results. rest_api implements the API of the server from the ground up: it defines the SQL tables as a series of Django models and exposes them RESTfully. client is a simple implementation of a client which interacts with both the API and the Websocket server to demonstrate a typical user session on the LHobby platform. Info The provided program is a command-line client which does not implement all the possible actions a user may actually take using the server directly with a REST client. It is therefore only intended to show the core functionality of the project, while much more could be achieved with a more complex client. In the next sections, interesting project parts will be explored more deeply.","title":"Project structure"},{"location":"code-description-and-examples/#packages-description","text":"DistributedProgrammingLHobby is the Django site directory, containing global settings for the whole server application. In particular, here it is defined: the HTTP handler (the rest_api package), the Websockets handler (the game package), the DBMS (SQLite3), the Django Channels channel_layer (a local Redis instance \u2014 a powerful engine was required for the game to be correctly handled in real-time with multiple connected users), supported authentication methods (token-auth aimed at stand-alone clients and cookie-based aimed at browser clients). docs is the package containing the Markdown files and the custom styles of this documentation, built with the Mkdocs static-site engine. game is responsible for handling the Websocket protocol requests, running the actual games using the code in the pong module, updating clients on the state of the game, and changing the database according to the match results. rest_api implements the API of the server from the ground up: it defines the SQL tables as a series of Django models and exposes them RESTfully. client is a simple implementation of a client which interacts with both the API and the Websocket server to demonstrate a typical user session on the LHobby platform. Info The provided program is a command-line client which does not implement all the possible actions a user may actually take using the server directly with a REST client. It is therefore only intended to show the core functionality of the project, while much more could be achieved with a more complex client. In the next sections, interesting project parts will be explored more deeply.","title":"Packages description"},{"location":"code-description-and-examples/game/","text":"In this section, the overall architecture of the actual game will be described, together with the reasons behind the decisions that were taken. Game structure \u00b6 Hexagonal architecture \u00b6 The game was developed from scratch because no implementation was found that was properly decoupled from the keyboard and a display. In fact, the game needed to easily communicate with the client code using sockets, and also using the keyboard for testing purposes. The game architecture is therefore centered on this purpose: it heavily relies on the so-called hexagonal architecture as described in this article and on the dependency injection pattern. Game files \u00b6 These are the files implementing the game logic: \u251c\u2500\u2500 ball.py \u251c\u2500\u2500 controller.py \u251c\u2500\u2500 game_rules.py \u2514\u2500\u2500 paddle.py Game objects \u00b6 Ball and paddles \u00b6 The game is object-oriented: ball.py and paddle.py implement the corresponding objects logic, exposing a move() method which updates their state. The ball doesn't need particular inputs because it just implements its physics relatively to the surrounding world, while the paddle takes a command input. Both methods take a time interval that is used to correctly update the objects state according to the amount of time elapsed since the last call. Controller \u00b6 The controller is the true center of the game: it uses constants and definitions in game_rules.py to determine global game rules, and requires external Input and Output classes to work with. It is responsible for handling the ball and the paddles to implement the game. When initialized, it starts a new thread in which the whole logic runs. Input interface The input class is used to take the paddles commands and process them: it needs to provide a left_paddle_input and a right_paddle_input attributes asynchronously. The controller will use their current value during the game loop. Must be thread-safe. Why attributes While attributes may seem arbitrary and limiting some Input implementation choices, the @property methods in Python work as attributes, removing this apparent limitation. Therefore, an implementer can create whatever logic they may feel fit, and the client will use the class cleanly. current_command = input . left_paddle_input # while an attribute, it can execute logic as a method if needed paddle . move ( delta_t , current_command ) Output interface The output class is used by the controller to communicate with the external clients at different times during the execution of the game. It needs to provide: a method init_game ( data : dict ) , called only once at the very start of the game with configuration parameters such as the width of the paddle, the length of the paddle, and the radius of the ball. It therefore signals that the game has started. a __call__ ( data : dict ) implementation which is called once every server tick , receiving game status data as a Python dict . It contains information about the ball and paddles positions, whether the ball has just bounced, the current match time, and other relevant current information. a method end_game ( data : dict ) , called only once to signal the final scores of the two players and the match time. Tip In order to avoid slowing down the game loop, it's best to implement the output class as a thread-safe queue which then gets read somewhere else. Actual input and output implementations \u00b6 Local game In order to test the game and the game only, an input-output implementation was created which used the keyboard presses and the screen. It can be found in the package game/pong/test/ , together with a testing.py module which can be executed stand-alone to test the game locally. Game controls The local game supports two players: the left player should use: W for moving the paddle upwards, S for moving the paddle downwards, Left Shift for accelerating the paddle movements. While the right player should use: Up for moving the paddle upwards, Down for moving the paddle downwards, Right Shift for accelerating the paddle movements. Queue-based In order to use the game from multiple threads correctly, an input-output implementation was created which makes use of a custom CircularQueue class. This thread-safe queue is based on the collections.deque class, can be configured to have a maximum size, after which old elements are replaced with new ones as they are inserted. The queue uses the wait/notify pattern with condition variables in order to expose a blocking get method. While the consumer of the Input queue is the controller itself and the producer is the websocket client, it is now needed a consumer for dequeueing the items in the Output queue inserted by the controller game loop. That is why the game/pong_output_consumer.py module was created. Its responsibility lies in dequeueing messages from the Output and sending them at the Django Channels group of the corresponding match. Then, each websocket will send to its client the message with the game status update. The output queue inserts a \"message_type\" key in the dictionary in order to propagate which of the three methods created the data object which was put in the queue. Here is a snippet which shows this behaviour: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from game.pong.queue.circular_queue import CircularQueue class QueueOutput : STATUS = 'status' INIT = 'init' END = 'end' def __init__ ( self , max_size : int ): self . queue = CircularQueue ( max_size ) def __call__ ( self , game_status : dict ): game_status_with_type = { 'message_type' : QueueOutput . STATUS } game_status_with_type . update ( game_status ) self . queue . put_nowait ( game_status_with_type ) def init ( self , game_info : dict ): game_info_with_type = { 'message_type' : QueueOutput . INIT } game_info_with_type . update ( game_info ) self . queue . put_nowait ( game_info_with_type ) def end_game ( self , game_info : dict ): game_info_with_type = { 'message_type' : QueueOutput . END } game_info_with_type . update ( game_info ) self . queue . put_nowait ( game_info_with_type ) The whole implementation of this is found in game/pong/queue/ . Caution The size of the queues is an important parameter to set. Let's imagine that the server experiences a brief connection problem and, as a consequence, the output queue starts to accumulate items to be sent. It is important that the clients receive the most up-to-date status as possible to be able to play correctly: therefore, dropping some old packets will actually be beneficial to the clients, even if they experience a slight jump in their view of the game. If the queue is too big , this packet drop never happens , and the clients risk living in the past if problems arise. If the queue is too small , packets could be dropped when they could be easily sent in time.","title":"Pong inner workings"},{"location":"code-description-and-examples/game/#game-structure","text":"","title":"Game structure"},{"location":"code-description-and-examples/game/#hexagonal-architecture","text":"The game was developed from scratch because no implementation was found that was properly decoupled from the keyboard and a display. In fact, the game needed to easily communicate with the client code using sockets, and also using the keyboard for testing purposes. The game architecture is therefore centered on this purpose: it heavily relies on the so-called hexagonal architecture as described in this article and on the dependency injection pattern.","title":"Hexagonal architecture"},{"location":"code-description-and-examples/game/#game-files","text":"These are the files implementing the game logic: \u251c\u2500\u2500 ball.py \u251c\u2500\u2500 controller.py \u251c\u2500\u2500 game_rules.py \u2514\u2500\u2500 paddle.py","title":"Game files"},{"location":"code-description-and-examples/game/#game-objects","text":"","title":"Game objects"},{"location":"code-description-and-examples/game/#ball-and-paddles","text":"The game is object-oriented: ball.py and paddle.py implement the corresponding objects logic, exposing a move() method which updates their state. The ball doesn't need particular inputs because it just implements its physics relatively to the surrounding world, while the paddle takes a command input. Both methods take a time interval that is used to correctly update the objects state according to the amount of time elapsed since the last call.","title":"Ball and paddles"},{"location":"code-description-and-examples/game/#controller","text":"The controller is the true center of the game: it uses constants and definitions in game_rules.py to determine global game rules, and requires external Input and Output classes to work with. It is responsible for handling the ball and the paddles to implement the game. When initialized, it starts a new thread in which the whole logic runs.","title":"Controller"},{"location":"code-description-and-examples/game/#actual-input-and-output-implementations","text":"","title":"Actual input and output implementations"},{"location":"code-description-and-examples/rest-api/","text":"Rest API \u00b6 In this section, interesting parts of the REST code will be explored and commented. Models \u00b6 Note Here, only code will be described: for the architecture, head to the database reference . Operating on users in OngoingMatch \u00b6 In the rest_api_ongoingmatch table, information about the currently playing users is not easily accessible. Furthermore, inserting and removing users consists of two operations, requiring both a change of role and of the ongoing_match foreign key of the user. Rather than repeating often-used queries, Python's computed properties were used in order to simulate having hosts, challengers and spectators readily available and modifiable directly in the OngoingMatch instance. This helped to reduce the verbosity of the code, to respect the Don't repeat yourself (DRY) principle and, more importantly, to avoid to forget to change both attributes in the user. 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @property def host ( self ) -> typing . Optional [ User ]: try : return self . user_set . get ( role = User . Role . HOST ) except User . DoesNotExist : return None @host . setter def host ( self , value : User ): if self . host : raise ValueError ( 'Host was already set' ) if value . ongoing_match : raise ValueError ( f 'User { value . username } is already in a match' ) value . ongoing_match = self value . role = User . Role . HOST value . save ( update_fields = [ 'role' , 'ongoing_match' ]) This snippet enables the use of simple syntax for accessing or setting the host of a match as if it were an attribute of the class: user = User . objects . get ( username = 'msilla' ) ongoing_match . host = user print ( ongoing_match . host ) >>> User ( < msilla > ) The setter property also validates the inserting operation, raising ValueError if incompatibilites arise. Code equivalents exist for the challenger and spectator roles, with the only exception being the spectator methods permitting multiple players with the same role. Ending a match \u00b6 In order to complete a match correctly, it is needed to: update the players' ELOs; set the role and the ongoing_match of the players to None ; delete the current OngoingMatch instance from the database; create a corresponding CompletedMatch instance to keep track of the games history. It is very important to conduct all of these operations in a single database transaction, in order to avoid leaving the data in an inconsistent state \u2014 either for brief durations while during the execution, or until human intervention if any errors happen before completing the set of needed operations. This is only one example of such a situation, which demonstrates the use of transactions in the Django Model API. Important In the following snippet, the ongoing_match foreign key is not updated because it is automatically set to NULL by the DBMS due to the configured on_delete policy. 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def complete_match ( self , winner : User , loser : User , winner_score : int , loser_score : int ) -> CompletedMatch : users = [ self . host , self . challenger ] if winner . username == loser . username : raise ValueError ( 'Winner and Loser must be different' ) if ( winner not in users ) or ( loser not in users ): raise ValueError ( 'User not playing the game' ) new_winner_elo , new_loser_elo = compute_elos ( winner , loser , winner_score , loser_score ) with transaction . atomic (): completed_match = CompletedMatch . objects . create ( winner = winner , loser = loser , start_timestamp = self . start_timestamp , winner_score = winner_score , loser_score = loser_score , winner_elo_before_match = winner . elo , loser_elo_before_match = loser . elo , winner_elo_after_match = new_winner_elo , loser_elo_after_match = new_loser_elo ) winner . elo = new_winner_elo loser . elo = new_loser_elo winner . role = None loser . role = None winner . save ( update_fields = [ 'elo' , 'role' ]) loser . save ( update_fields = [ 'elo' , 'role' ]) self . delete () return completed_match Views \u00b6 While much of the views code is straightforward, there are interesting edge cases to take into account. OngoingMatch creation \u00b6 When an OngoingMatch is created by a soon-to-be host via a POST request, it must also be linked to the user that started the request, in order to keep track of the ownership of the match. Therefore, the match instance is created, and then the user must be updated by setting the new instance as the user's current match. If the user is already in a game when making the request, or any unanticipated errors happen after having created the match, the database is left in an inconsistent state; a transaction is necessary to avoid this. 53 54 55 56 57 58 59 60 61 62 def create ( self , request , * args , ** kwargs ): with transaction . atomic (): new_ongoing_match = OngoingMatch . objects . create () try : new_ongoing_match . host = request . user except ValueError as e : raise serializers . ValidationError ( str ( e )) serializer = OngoingMatchSerializer ( instance = new_ongoing_match ) return Response ( serializer . data , status = status . HTTP_201_CREATED ) This code structure enforces a rollback of the database operations if any errors occur, while alerting the user. Otherwise, a normal HTTP 201 response is returned together with the new object representation in the body, respecting REST design principles. Clean views No substantial logic is therefore executed in the views, which only glue together other code: the error validation is done inside the model (just as described in the previous section ), the serialization of the new instance to a Python dict is handled by the serializer, and the JSON serialization is made by the Response internal handlers.","title":"REST API"},{"location":"code-description-and-examples/rest-api/#rest-api","text":"In this section, interesting parts of the REST code will be explored and commented.","title":"Rest API"},{"location":"code-description-and-examples/rest-api/#models","text":"Note Here, only code will be described: for the architecture, head to the database reference .","title":"Models"},{"location":"code-description-and-examples/rest-api/#operating-on-users-in-ongoingmatch","text":"In the rest_api_ongoingmatch table, information about the currently playing users is not easily accessible. Furthermore, inserting and removing users consists of two operations, requiring both a change of role and of the ongoing_match foreign key of the user. Rather than repeating often-used queries, Python's computed properties were used in order to simulate having hosts, challengers and spectators readily available and modifiable directly in the OngoingMatch instance. This helped to reduce the verbosity of the code, to respect the Don't repeat yourself (DRY) principle and, more importantly, to avoid to forget to change both attributes in the user. 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @property def host ( self ) -> typing . Optional [ User ]: try : return self . user_set . get ( role = User . Role . HOST ) except User . DoesNotExist : return None @host . setter def host ( self , value : User ): if self . host : raise ValueError ( 'Host was already set' ) if value . ongoing_match : raise ValueError ( f 'User { value . username } is already in a match' ) value . ongoing_match = self value . role = User . Role . HOST value . save ( update_fields = [ 'role' , 'ongoing_match' ]) This snippet enables the use of simple syntax for accessing or setting the host of a match as if it were an attribute of the class: user = User . objects . get ( username = 'msilla' ) ongoing_match . host = user print ( ongoing_match . host ) >>> User ( < msilla > ) The setter property also validates the inserting operation, raising ValueError if incompatibilites arise. Code equivalents exist for the challenger and spectator roles, with the only exception being the spectator methods permitting multiple players with the same role.","title":"Operating on users in OngoingMatch"},{"location":"code-description-and-examples/rest-api/#ending-a-match","text":"In order to complete a match correctly, it is needed to: update the players' ELOs; set the role and the ongoing_match of the players to None ; delete the current OngoingMatch instance from the database; create a corresponding CompletedMatch instance to keep track of the games history. It is very important to conduct all of these operations in a single database transaction, in order to avoid leaving the data in an inconsistent state \u2014 either for brief durations while during the execution, or until human intervention if any errors happen before completing the set of needed operations. This is only one example of such a situation, which demonstrates the use of transactions in the Django Model API. Important In the following snippet, the ongoing_match foreign key is not updated because it is automatically set to NULL by the DBMS due to the configured on_delete policy. 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def complete_match ( self , winner : User , loser : User , winner_score : int , loser_score : int ) -> CompletedMatch : users = [ self . host , self . challenger ] if winner . username == loser . username : raise ValueError ( 'Winner and Loser must be different' ) if ( winner not in users ) or ( loser not in users ): raise ValueError ( 'User not playing the game' ) new_winner_elo , new_loser_elo = compute_elos ( winner , loser , winner_score , loser_score ) with transaction . atomic (): completed_match = CompletedMatch . objects . create ( winner = winner , loser = loser , start_timestamp = self . start_timestamp , winner_score = winner_score , loser_score = loser_score , winner_elo_before_match = winner . elo , loser_elo_before_match = loser . elo , winner_elo_after_match = new_winner_elo , loser_elo_after_match = new_loser_elo ) winner . elo = new_winner_elo loser . elo = new_loser_elo winner . role = None loser . role = None winner . save ( update_fields = [ 'elo' , 'role' ]) loser . save ( update_fields = [ 'elo' , 'role' ]) self . delete () return completed_match","title":"Ending a match"},{"location":"code-description-and-examples/rest-api/#views","text":"While much of the views code is straightforward, there are interesting edge cases to take into account.","title":"Views"},{"location":"code-description-and-examples/rest-api/#ongoingmatch-creation","text":"When an OngoingMatch is created by a soon-to-be host via a POST request, it must also be linked to the user that started the request, in order to keep track of the ownership of the match. Therefore, the match instance is created, and then the user must be updated by setting the new instance as the user's current match. If the user is already in a game when making the request, or any unanticipated errors happen after having created the match, the database is left in an inconsistent state; a transaction is necessary to avoid this. 53 54 55 56 57 58 59 60 61 62 def create ( self , request , * args , ** kwargs ): with transaction . atomic (): new_ongoing_match = OngoingMatch . objects . create () try : new_ongoing_match . host = request . user except ValueError as e : raise serializers . ValidationError ( str ( e )) serializer = OngoingMatchSerializer ( instance = new_ongoing_match ) return Response ( serializer . data , status = status . HTTP_201_CREATED ) This code structure enforces a rollback of the database operations if any errors occur, while alerting the user. Otherwise, a normal HTTP 201 response is returned together with the new object representation in the body, respecting REST design principles. Clean views No substantial logic is therefore executed in the views, which only glue together other code: the error validation is done inside the model (just as described in the previous section ), the serialization of the new instance to a Python dict is handled by the serializer, and the JSON serialization is made by the Response internal handlers.","title":"OngoingMatch creation"},{"location":"external-dependencies/","text":"Overview \u00b6 Topics external to the course are described in this section. Django \u00b6 Django is a Python web framework aimed at providing much of the usual boilerplate code as built-in directly out of the box. For what concerns this project, it provided easy management of a database through the Django Object Relational Mapping (ORM) , registration of users, session management, multithreaded request handling. In particular, the ORM was extremely useful for easily modifying and accessing the database directly in Python, abstracting the SQL tables as object-oriented classes: the Django models. It also made possible the version control of the different database changes through the proper use of migrations ; this helped the collaborative process, especially by making sure everyone on the team had the same version of the database. The migrations also help decoupling the database schema from the actual DBMS being used - since they are Python code, they are translated into the correct SQL dialect when the DBMS is configured, letting us not worry about which one to choose early on: a simple one, SQLite, was chosen, and if it were to be changed (due to for example performance issues), no problems would have arisen. Note While learning to use this framework and related tools took a substantial chunk of time from the actual development, it ended up being a good investment: it speeded up the construction of the features we wanted to implement and avoided the reinvention of the wheel . Usually, Django is used stand-alone only in order to build Web pages; what we did want was instead a REST API, in order to be independent from the particular choice of client. So, the actual HTTP and Websocket requests were served by two Django libraries which expand the framework capabilities. Django REST framework \u00b6 Django REST framework adapts Django normal operations to work with HTTP methods commonly used in REST APIs, such as DELETE , providing with standard implementations \u2014 in this example, it would remove the requested resource. This particular framework was chosen because well integrated with the Django ORM: resources are, if necessary, able to be directly mapped to Django models. Moreover, it exposes a Browsable API: if you navigate to a REST endpoint, you can use it seamlessly in a nice user interface directly from the browser. This grants a nice client for the API and was also very useful during the development. Websockets \u00b6 The game itself is a real-time application. Building one with REST calls is not ideal, especially in the case of a game, where the server sends information about its state periodically without the clients requesting. Therefore, a better-suited protocol was needed: Websockets were chosen because they are full-duplex, work well in real-time, but primarily because they are based on an HTTP handshake. This means that browser clients are easily supported (support otherwise not achievable using normal UDP or TCP sockets), and user authentication can be handled with the same means used in the REST API. Django Channels Django does not support Websockets, but the same organization maintains Django Channels, an extension of the framework which implements Websockets and other long-running protocols, such as MQTT. As REST framework, it has access to the Django ORM. An important peculiarity of Channels is the channel layer , a system which allowed us to exchange messages between the different Websocket handlers, the consumers . In particular, each Websocket connection of LHobby is linked to a channel group ; whenever there is a message that is to be sent to all the participants of a match (such as a game update), the server code sends it to the channel group. The channel layer then sends the message to each consumer, which handles it by simply sending it to the corresponding Websocket.","title":"External dependencies"},{"location":"external-dependencies/#overview","text":"Topics external to the course are described in this section.","title":"Overview"},{"location":"external-dependencies/#django","text":"Django is a Python web framework aimed at providing much of the usual boilerplate code as built-in directly out of the box. For what concerns this project, it provided easy management of a database through the Django Object Relational Mapping (ORM) , registration of users, session management, multithreaded request handling. In particular, the ORM was extremely useful for easily modifying and accessing the database directly in Python, abstracting the SQL tables as object-oriented classes: the Django models. It also made possible the version control of the different database changes through the proper use of migrations ; this helped the collaborative process, especially by making sure everyone on the team had the same version of the database. The migrations also help decoupling the database schema from the actual DBMS being used - since they are Python code, they are translated into the correct SQL dialect when the DBMS is configured, letting us not worry about which one to choose early on: a simple one, SQLite, was chosen, and if it were to be changed (due to for example performance issues), no problems would have arisen. Note While learning to use this framework and related tools took a substantial chunk of time from the actual development, it ended up being a good investment: it speeded up the construction of the features we wanted to implement and avoided the reinvention of the wheel . Usually, Django is used stand-alone only in order to build Web pages; what we did want was instead a REST API, in order to be independent from the particular choice of client. So, the actual HTTP and Websocket requests were served by two Django libraries which expand the framework capabilities.","title":"Django"},{"location":"external-dependencies/#django-rest-framework","text":"Django REST framework adapts Django normal operations to work with HTTP methods commonly used in REST APIs, such as DELETE , providing with standard implementations \u2014 in this example, it would remove the requested resource. This particular framework was chosen because well integrated with the Django ORM: resources are, if necessary, able to be directly mapped to Django models. Moreover, it exposes a Browsable API: if you navigate to a REST endpoint, you can use it seamlessly in a nice user interface directly from the browser. This grants a nice client for the API and was also very useful during the development.","title":"Django REST framework"},{"location":"external-dependencies/#websockets","text":"The game itself is a real-time application. Building one with REST calls is not ideal, especially in the case of a game, where the server sends information about its state periodically without the clients requesting. Therefore, a better-suited protocol was needed: Websockets were chosen because they are full-duplex, work well in real-time, but primarily because they are based on an HTTP handshake. This means that browser clients are easily supported (support otherwise not achievable using normal UDP or TCP sockets), and user authentication can be handled with the same means used in the REST API.","title":"Websockets"},{"location":"interfaces/rest-api/","text":"REST API \u00b6 Overview \u00b6 This section shows the list of all the resources available in the LHobby REST API. Some endpoints require authentication. Authentication If you see this icon, the endpoint requires authentication. If you see this icon, the endpoint does not require authentication. Authentication \u00b6 There are two ways to do an authenticated request. Token : if you have an authentication token you can do an authenticated request using the header key Authorization with Token <authentication token> as value. Cookie : if you are using a browser you can authenticate via the Cookie header key. Cookie based login \u00b6 Login into the system. This endpoint is better suited for browser clients. post /HOST:PORT/api/login/ Parameters Name Type In Description Required username string body true password string body true next string param the url you will be redirected to false OK response Status: 302 Found Cookie based logout \u00b6 Logout from the system. This endpoint is better suited for browser clients. post /HOST:PORT/api/logout/ Parameters Name Type In Description Required Cookie string header session cookie for authentication true OK response Status: 200 OK Get authorization token \u00b6 Use this endpoint to generate a token for the authentication. post /HOST:PORT/api/token/ Parameters Name Type In Description Required username string body true password string body true OK response Status: 200 OK { \"token\" : \"b8a60e83569600e8f5c323428cca736ce9176e0f\" } Delete authorization token \u00b6 Use this endpoint to delete a specific user token. delete /HOST:PORT/api/token/ Parameters Name Type In Description Required Authorization string header token for authentication, it must be in this form: Token true Response Status: 204 No Content API Reference \u00b6 Create a new user \u00b6 It allows to create a new user. post /HOST:PORT/api/users/sign_up/ Parameters Name Type In Description Required username string body the username of the user true password string body the password must contain at least 8 characters and it must not be too similar to the username true email string body user email false first_name string body user first name false last_name string body user last name false Created response Status: 201 Created { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : null , \"role\" : null , \"first_name\" : \"\" , \"last_name\" : \"\" } List users \u00b6 List all registered users. get /HOST:PORT/api/users/ Parameters Name Type In Description Required ordering string param if equal to one in [elo, -elo, username, -username] the user list will be ordered false OK response Status: 200 OK [ { \"username\" : \"emanuele\" , \"date_joined\" : \"2021-01-15T23:17:32.966236Z\" , \"elo\" : 900 , \"ongoing_match\" : 40 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, { \"username\" : \"davide\" , \"date_joined\" : \"2021-01-15T23:18:11.368676Z\" , \"elo\" : 1000 , \"ongoing_match\" : null , \"role\" : null , \"first_name\" : \"\" , \"last_name\" : \"\" }, { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : null , \"role\" : null , \"first_name\" : \"\" , \"last_name\" : \"\" } ] User detail \u00b6 Get detail of specific user using his username . get /HOST:PORT/api/users/{username}/ Parameters Name Type In Description Required username string path true OK response Status: 200 OK { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : null , \"role\" : null , \"first_name\" : \"\" , \"last_name\" : \"\" } Ongoing match of a specific user \u00b6 Get the ongoing match of a specific user. get /HOST:PORT/api/users/{username}/ongoing_match/ Parameters Name Type In Description Required username string path true OK response Status: 200 OK { \"id\" : 40 , \"host\" : { \"username\" : \"emanuele\" , \"date_joined\" : \"2021-01-15T23:17:32.966236Z\" , \"elo\" : 900 , \"ongoing_match\" : 40 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : null , \"creation_timestamp\" : \"2021-01-18T18:34:09.576490Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false } Create a new ongoing match \u00b6 It allows to create a new match for the authenticated user, setting them as host of the match. post /HOST:PORT/api/ongoing_matches/ Created response Status: 201 Created { \"id\" : 41 , \"host\" : { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : null , \"creation_timestamp\" : \"2021-01-19T09:56:45.727233Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false } Warning The user must not be already playing or spectating another match, otherwise the following response will be returned: Status: 400 Bad Request [ \"User davide is already in a match\" ] List ongoing matches \u00b6 List all ongoing matches. get /HOST:PORT/api/ongoing_matches/ Parameters Name Type In Description Required ordering string param if equal to one in [host_elo, -host_elo] the ongoing match list will be ordered false is_full bool param if true, only the matches that already have a challenger will be returned, otherwise the ones without a challenger false max_elo number param if given, the ongoing matches hosted by an user with an elo greater than max_elo will not be returned false min_elo number param if given the the ongoing matches hosted by an user with an elo less than min_elo will not be returned false OK response Status: 200 OK [ { \"id\" : 40 , \"host\" : { \"username\" : \"emanuele\" , \"date_joined\" : \"2021-01-15T23:17:32.966236Z\" , \"elo\" : 900 , \"ongoing_match\" : 40 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : null , \"creation_timestamp\" : \"2021-01-18T18:34:09.576490Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false }, { \"id\" : 41 , \"host\" : { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : { \"username\" : \"davide\" , \"date_joined\" : \"2021-01-15T23:18:11.368676Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"C\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"creation_timestamp\" : \"2021-01-19T09:56:45.727233Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false } ] Ongoing match detail \u00b6 Get detail of a specific ongoing match using his id . get /HOST:PORT/api/ongoing_matches/{id}/ Parameters Name Type In Description Required id string path id number of the ongoing match true OK response Status: 200 OK { \"id\" : 41 , \"host\" : { \"username\" : \"marta\" , \"date_joined\" : \"2021-01-18T19:08:25.023237Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"H\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"spectators\" : [], \"challenger\" : { \"username\" : \"davide\" , \"date_joined\" : \"2021-01-15T23:18:11.368676Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"C\" , \"first_name\" : \"\" , \"last_name\" : \"\" }, \"creation_timestamp\" : \"2021-01-19T09:56:45.727233Z\" , \"start_timestamp\" : null , \"is_started\" : false , \"is_challenger_ready\" : false } Delete specific ongoing match \u00b6 Delete a specific ongoing match given the match id . delete /HOST:PORT/api/ongoing_matches/{id}/ Note An ongoing match can be deleted only from its host and only if it is not started yet. Parameters Name Type In Description Required id string path id number of the ongoing match to delete true Response Status: 204 No Content Ongoing match user detail \u00b6 Get detail of the host, the challenger or the spectators of a specific match. get /HOST:PORT/api/ongoing_matches/{id}/{role}/ Parameters Name Type In Description Required id string path id number of the ongoing match true role string path choose one in [host, challenger, spectators] true OK response Status: 200 OK { \"username\" : \"davide\" , \"date_joined\" : \"2021-01-15T23:18:11.368676Z\" , \"elo\" : 1000 , \"ongoing_match\" : 41 , \"role\" : \"C\" , \"first_name\" : \"\" , \"last_name\" : \"\" } Creation of a completed match \u00b6 Completed matches are only automatically generated after the end of an ongoing match. List completed matches \u00b6 List all completed matches. get /HOST:PORT/api/completed_matches/ Parameters Name Type In Description Required ordering string param if equal to one in [id, winner, loser, start_timestamp, end_timestamp, completion_timestamp, winner_score, loser_score, winner_elo_before_match, winner_elo_after_match, loser_elo_before_match, loser_elo_after_match] the ongoing match list will be ordered. Put a ' - ' before the ordering type for descending order false winner string param filter completed matches with a specific winner false loser string param filter completed matches with a specific loser false user string param filter completed matches with a specific user, it is not important if it is a winner or a loser false end_timestamp_after datetime param the matches completed before the passed parameter will not be returned false end_timestamp_before datetime param the matches completed after the passed parameter will not be returned false Note datetime parameters must be formatted as: yy:mm:dd OK response Status: 200 OK [ { \"id\" : 1 , \"winner\" : \"davide\" , \"loser\" : \"emanuele\" , \"start_timestamp\" : \"2021-01-16T16:40:51.981401Z\" , \"completion_timestamp\" : \"2021-01-16T16:41:20.669025Z\" , \"winner_score\" : 5 , \"loser_score\" : 4 , \"winner_elo_before_match\" : 1000 , \"loser_elo_before_match\" : 1000 , \"winner_elo_after_match\" : 1050 , \"loser_elo_after_match\" : 950 } ] Completed match detail \u00b6 Get detail of specific completed match using his id . get /HOST:PORT/api/completed_matches/{id}/ Parameters Name Type In Description Required id string path id number of the completed match true OK response Status: 200 OK { \"id\" : 1 , \"winner\" : \"davide\" , \"loser\" : \"emanuele\" , \"start_timestamp\" : \"2021-01-16T16:40:51.981401Z\" , \"completion_timestamp\" : \"2021-01-16T16:41:20.669025Z\" , \"winner_score\" : 5 , \"loser_score\" : 4 , \"winner_elo_before_match\" : 1000 , \"loser_elo_before_match\" : 1000 , \"winner_elo_after_match\" : 1050 , \"loser_elo_after_match\" : 950 } The API REST can be used in order to create a new match or to visualize the available ongoing matches. To join a match and play or spectate it clients shall use a websocket protocol. Next section will discuss such websocket protocol.","title":"REST API"},{"location":"interfaces/rest-api/#rest-api","text":"","title":"REST API"},{"location":"interfaces/rest-api/#overview","text":"This section shows the list of all the resources available in the LHobby REST API. Some endpoints require authentication. Authentication If you see this icon, the endpoint requires authentication. If you see this icon, the endpoint does not require authentication.","title":"Overview"},{"location":"interfaces/rest-api/#authentication","text":"There are two ways to do an authenticated request. Token : if you have an authentication token you can do an authenticated request using the header key Authorization with Token <authentication token> as value. Cookie : if you are using a browser you can authenticate via the Cookie header key.","title":"Authentication"},{"location":"interfaces/rest-api/#cookie-based-login","text":"Login into the system. This endpoint is better suited for browser clients. post /HOST:PORT/api/login/","title":" Cookie based login"},{"location":"interfaces/rest-api/#cookie-based-logout","text":"Logout from the system. This endpoint is better suited for browser clients. post /HOST:PORT/api/logout/","title":" Cookie based logout"},{"location":"interfaces/rest-api/#get-authorization-token","text":"Use this endpoint to generate a token for the authentication. post /HOST:PORT/api/token/","title":" Get authorization token"},{"location":"interfaces/rest-api/#delete-authorization-token","text":"Use this endpoint to delete a specific user token. delete /HOST:PORT/api/token/","title":" Delete authorization token"},{"location":"interfaces/rest-api/#api-reference","text":"","title":"API Reference"},{"location":"interfaces/rest-api/#create-a-new-user","text":"It allows to create a new user. post /HOST:PORT/api/users/sign_up/","title":" Create a new user"},{"location":"interfaces/rest-api/#list-users","text":"List all registered users. get /HOST:PORT/api/users/","title":" List users"},{"location":"interfaces/rest-api/#user-detail","text":"Get detail of specific user using his username . get /HOST:PORT/api/users/{username}/","title":" User detail"},{"location":"interfaces/rest-api/#ongoing-match-of-a-specific-user","text":"Get the ongoing match of a specific user. get /HOST:PORT/api/users/{username}/ongoing_match/","title":" Ongoing match of a specific user"},{"location":"interfaces/rest-api/#create-a-new-ongoing-match","text":"It allows to create a new match for the authenticated user, setting them as host of the match. post /HOST:PORT/api/ongoing_matches/","title":" Create a new ongoing match"},{"location":"interfaces/rest-api/#list-ongoing-matches","text":"List all ongoing matches. get /HOST:PORT/api/ongoing_matches/","title":" List ongoing matches"},{"location":"interfaces/rest-api/#ongoing-match-detail","text":"Get detail of a specific ongoing match using his id . get /HOST:PORT/api/ongoing_matches/{id}/","title":" Ongoing match detail"},{"location":"interfaces/rest-api/#delete-specific-ongoing-match","text":"Delete a specific ongoing match given the match id . delete /HOST:PORT/api/ongoing_matches/{id}/ Note An ongoing match can be deleted only from its host and only if it is not started yet.","title":" Delete specific ongoing match"},{"location":"interfaces/rest-api/#ongoing-match-user-detail","text":"Get detail of the host, the challenger or the spectators of a specific match. get /HOST:PORT/api/ongoing_matches/{id}/{role}/","title":" Ongoing match user detail"},{"location":"interfaces/rest-api/#creation-of-a-completed-match","text":"Completed matches are only automatically generated after the end of an ongoing match.","title":"Creation of a completed match"},{"location":"interfaces/rest-api/#list-completed-matches","text":"List all completed matches. get /HOST:PORT/api/completed_matches/","title":" List completed matches"},{"location":"interfaces/rest-api/#completed-match-detail","text":"Get detail of specific completed match using his id . get /HOST:PORT/api/completed_matches/{id}/","title":" Completed match detail"},{"location":"interfaces/websockets/","text":"Websockets \u00b6 Overview \u00b6 This section shows the communication protocol between a client and the websocket server. The possible messages are related to the game phase and to the role of the client in the match. The client must be authenticated to communicate with the server. Protocol description \u00b6 Connection phase \u00b6 First of all, the client should start the communication with the server. In this phase the user must specify the role and the id of the match to join. In order to start the communication, the client must open a websocket connection using the following url: ws://HOST:PORT/ws/game/{match_id}/?role={role} The connection may be rejected due to several errors described below. Role independent errors The match ID does not exist: { \"error\" : \"non existent requested match\" , \"code\" : 5 } The user is not authenticated: { \"error\" : \"unauthenticated user, please send auth token\" , \"code\" : 6 } The query string contains more than one parameter or is not well formed: { \"error\" : \"bad key in query string. expected: role\" , \"code\" : 7 } The requested role is not in [host, challenger, spectator] : { \"error\" : \"bad value in query string. expected: [spectator, host, challenger]\" , \"code\" : 7 } Challenger or spectator related error The client requested to be a spectator or a challenger but the user is already in a match or the match is full: { \"error\" : \"trying to join a match while already in another match or the match is full\" , \"code\" : 9 } Host related error The client requested to be an host of a match different from the one already hosted: { \"error\" : \"trying to join a match as host which you did not start\" , \"code\" : 8 } Success Finally, if everything is ok for the server, the connection is established, and the client receives: { \"status\" : \"success\" , \"code\" : 0 } From now on the websocket server can receive different type of commands from its client. If the requested role is spectator , the websocket server will ignore all the commands coming from that user. Game initialization phase \u00b6 After having established the connection with the websocket server for a specific ongoing match, it is time to start the game. The host of the match is responsible for starting the match. A match can start only if a challenger is present and is ready to play. Role independent error If a client sends a message without the command keyword, the websocket server will always answer as below: { \"error\" : \"no command sent\" , \"code\" : 2 } Challenger ready A challenger in order to communicate that is ready to play must send the following command: { \"command\" : \"ready\" } From this moment, until the match begins, all commands sent from the challenger will be ignored and the client will receive the following error: { \"error\" : \"invalid command\" , \"code\" : 2 } Host start match In order to start the match the host must send the following command: { \"command\" : \"start_match\" } This will start the game thread if the challenger is ready, otherwise the host will receive an error as follow: { \"error\" : \"challenger not ready\" , \"code\" : 3 } Game phase \u00b6 The game has started and now the pong game screen is built by the clients connected to the same match, taking into account the parameters inside the init message, such as: { \"message_type\" : \"init\" , \"ball_radius\" : 0.02 , \"paddle_height\" : 0.13 , \"paddle_width\" : 0.02 } During the match the host controls the left paddle and the challenger the right one. In order to play, users can send the following commands: { \"command\" : \"up\" } { \"command\" : \"down\" } { \"command\" : \"fup\" } { \"command\" : \"fdown\" } During the game, for each game_tick , the websocket server sends the clients all the messages containing the information necessary to update the game status. { \"message_type\" : \"status\" , \"has_bounced\" : true , \"left_paddle_margin_reached\" : false , \"right_paddle_margin_reached\" : true , \"left_score\" : 4 , \"right_score\" : 3 , \"left_paddle_y\" : 0.5 , \"right_paddle_y\" : 0.3 , \"ball_x\" : 0.6 , \"ball_y\" : 1 , \"match_time\" : 33 , \"sudden_death\" : false } When the match is over, the server sends all participants a end message. The information is contained in a serialized completed match object \u2014 the same that would be sent from the completed match API . { \"message_type\" : \"end\" , \"id\" : 1 , \"winner\" : \"davide\" , \"loser\" : \"emanuele\" , \"start_timestamp\" : \"2021-01-16T16:40:51.981401Z\" , \"completion_timestamp\" : \"2021-01-16T16:41:20.669025Z\" , \"winner_score\" : 5 , \"loser_score\" : 4 , \"winner_elo_before_match\" : 1000 , \"loser_elo_before_match\" : 1000 , \"winner_elo_after_match\" : 1050 , \"loser_elo_after_match\" : 950 }","title":"Websockets"},{"location":"interfaces/websockets/#websockets","text":"","title":"Websockets"},{"location":"interfaces/websockets/#overview","text":"This section shows the communication protocol between a client and the websocket server. The possible messages are related to the game phase and to the role of the client in the match. The client must be authenticated to communicate with the server.","title":"Overview"},{"location":"interfaces/websockets/#protocol-description","text":"","title":"Protocol description"},{"location":"interfaces/websockets/#connection-phase","text":"First of all, the client should start the communication with the server. In this phase the user must specify the role and the id of the match to join. In order to start the communication, the client must open a websocket connection using the following url: ws://HOST:PORT/ws/game/{match_id}/?role={role} The connection may be rejected due to several errors described below.","title":"Connection phase"},{"location":"interfaces/websockets/#game-initialization-phase","text":"After having established the connection with the websocket server for a specific ongoing match, it is time to start the game. The host of the match is responsible for starting the match. A match can start only if a challenger is present and is ready to play.","title":"Game initialization phase"},{"location":"interfaces/websockets/#game-phase","text":"The game has started and now the pong game screen is built by the clients connected to the same match, taking into account the parameters inside the init message, such as: { \"message_type\" : \"init\" , \"ball_radius\" : 0.02 , \"paddle_height\" : 0.13 , \"paddle_width\" : 0.02 } During the match the host controls the left paddle and the challenger the right one. In order to play, users can send the following commands: { \"command\" : \"up\" } { \"command\" : \"down\" } { \"command\" : \"fup\" } { \"command\" : \"fdown\" } During the game, for each game_tick , the websocket server sends the clients all the messages containing the information necessary to update the game status. { \"message_type\" : \"status\" , \"has_bounced\" : true , \"left_paddle_margin_reached\" : false , \"right_paddle_margin_reached\" : true , \"left_score\" : 4 , \"right_score\" : 3 , \"left_paddle_y\" : 0.5 , \"right_paddle_y\" : 0.3 , \"ball_x\" : 0.6 , \"ball_y\" : 1 , \"match_time\" : 33 , \"sudden_death\" : false } When the match is over, the server sends all participants a end message. The information is contained in a serialized completed match object \u2014 the same that would be sent from the completed match API . { \"message_type\" : \"end\" , \"id\" : 1 , \"winner\" : \"davide\" , \"loser\" : \"emanuele\" , \"start_timestamp\" : \"2021-01-16T16:40:51.981401Z\" , \"completion_timestamp\" : \"2021-01-16T16:41:20.669025Z\" , \"winner_score\" : 5 , \"loser_score\" : 4 , \"winner_elo_before_match\" : 1000 , \"loser_elo_before_match\" : 1000 , \"winner_elo_after_match\" : 1050 , \"loser_elo_after_match\" : 950 }","title":"Game phase"},{"location":"introduction/installation/","text":"Installation \u00b6 Get the source code \u00b6 First of all, clone the LHobby repository from github into your system. git clone https://github.com/Pentracchiano/DistributedProgrammingLHobby.git Install Dependencies \u00b6 Two requirements.txt files are provided to install the dependencies. One is related to server dependencies and the other is related to client dependencies. It is recommended, not necessary, to install the dependencies into a python virtual environment . Info The code has been tested only with Python 3.6 and Python 3.7 . First of all create the virtual environment (you can skip this procedure). python3 -m venv venv From the same folder you executed the previous command, activate the python environment. Windows venv\\Scripts\\activate Linux/macOS source venv/bin/activate # sh, bash, or zsh . ./venv/bin/activate.fish # fish source venv/bin/activate.csh # csh or tcsh Tip To deactivate the virtual environment, simply launch deactivate into a shell. Now you should navigate into the project directory. cd DistributedProgrammingLHobby Install the server dependencies. pip install -r requirements.txt If you want to test the client built for the project you must also install the client dependencies. Windows pip install -r client\\requirements.txt Linux/macOS pip install -r client/requirements.txt After the installation, you are ready to discover how to use LHobby. Go to the next section for usage documentation.","title":"Installation"},{"location":"introduction/installation/#installation","text":"","title":"Installation"},{"location":"introduction/installation/#get-the-source-code","text":"First of all, clone the LHobby repository from github into your system. git clone https://github.com/Pentracchiano/DistributedProgrammingLHobby.git","title":"Get the source code"},{"location":"introduction/installation/#install-dependencies","text":"Two requirements.txt files are provided to install the dependencies. One is related to server dependencies and the other is related to client dependencies. It is recommended, not necessary, to install the dependencies into a python virtual environment . Info The code has been tested only with Python 3.6 and Python 3.7 . First of all create the virtual environment (you can skip this procedure). python3 -m venv venv From the same folder you executed the previous command, activate the python environment. Windows venv\\Scripts\\activate Linux/macOS source venv/bin/activate # sh, bash, or zsh . ./venv/bin/activate.fish # fish source venv/bin/activate.csh # csh or tcsh Tip To deactivate the virtual environment, simply launch deactivate into a shell. Now you should navigate into the project directory. cd DistributedProgrammingLHobby Install the server dependencies. pip install -r requirements.txt If you want to test the client built for the project you must also install the client dependencies. Windows pip install -r client\\requirements.txt Linux/macOS pip install -r client/requirements.txt After the installation, you are ready to discover how to use LHobby. Go to the next section for usage documentation.","title":"Install Dependencies"},{"location":"introduction/usage/","text":"Usage \u00b6 Server \u00b6 The server is built starting from the Django development server, a lightweight Web server written purely in Python. It has been used in order to test and develop things rapidly without having to deal with configuring a production server \u2013 such as Apache. So, in order to start the server, you have to launch the following django command: python3 manage.py runserver This command starts the development server on localhost at port 8000. It is also possible to choose the port: python3 manage.py runserver 8080 It is now possible to navigate the REST API and send requests to the server. To check all the available endpoints and how to use them refer to the REST API Reference . For example you can start creating a new user : POST http://127.0.0.1:8000/api/users/sign_up/ In the request body you can simply pass: { \"username\" : \"cool-username\" , \"password\" : \"strong-password\" } Client \u00b6 A simple Python client has been developed to test the REST API server and the Websocket server. It assumes that you're running the server at port 8000. Launch the client with the following command: Windows python3 client\\pygame_client.py Linux/macOS python3 client/pygame_client.py The client allows you to login into the system, create or join a match and play against other users. Obviously you can execute two or more instances of the client to simulate more users connected to the system. Once you are in a match, and the pong screen is shown, you can play the game using the following keyboard commands: Game controls W for moving the paddle upwards, S for moving the paddle downwards, Left Shift for accelerating the paddle movements. Enjoy your game! :)","title":"Usage"},{"location":"introduction/usage/#usage","text":"","title":"Usage"},{"location":"introduction/usage/#server","text":"The server is built starting from the Django development server, a lightweight Web server written purely in Python. It has been used in order to test and develop things rapidly without having to deal with configuring a production server \u2013 such as Apache. So, in order to start the server, you have to launch the following django command: python3 manage.py runserver This command starts the development server on localhost at port 8000. It is also possible to choose the port: python3 manage.py runserver 8080 It is now possible to navigate the REST API and send requests to the server. To check all the available endpoints and how to use them refer to the REST API Reference . For example you can start creating a new user : POST http://127.0.0.1:8000/api/users/sign_up/ In the request body you can simply pass: { \"username\" : \"cool-username\" , \"password\" : \"strong-password\" }","title":"Server"},{"location":"introduction/usage/#client","text":"A simple Python client has been developed to test the REST API server and the Websocket server. It assumes that you're running the server at port 8000. Launch the client with the following command: Windows python3 client\\pygame_client.py Linux/macOS python3 client/pygame_client.py The client allows you to login into the system, create or join a match and play against other users. Obviously you can execute two or more instances of the client to simulate more users connected to the system. Once you are in a match, and the pong screen is shown, you can play the game using the following keyboard commands: Game controls W for moving the paddle upwards, S for moving the paddle downwards, Left Shift for accelerating the paddle movements. Enjoy your game! :)","title":"Client"}]}